// Generated by CoffeeScript 2.4.1
(function() {
  // Provides an easy way to animate movement of
  // DOM objects.
  var Animation, BaseNode, ChecklistNode, ClickHandler, Mindmap, PanHandler, TextNode, VideoNode, getOuterHeight, getText, isDescendant, measureTextWidth, nodeCounter, recursiveHasClass, supportedNodeTypes;

  Animation = class Animation {
    // Sets the element to animate.
    constructor(element1) {
      this.element = element1;
      this.matrix = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    }

    // Moving animation to move an element from a given position
    // to a target position over the course of 'durationMS' ms.
    move(fromX, fromY, toX, toY, durationMS, callback = false) {
      var curS, step, steps;
      steps = durationMS / 16;
      curS = 0;
      step = () => {
        curS += Math.PI / steps;
        this.matrix[12] += ((toX - fromX) / steps) * (Math.sin(curS) ** 2) * 2;
        this.matrix[13] += ((toY - fromY) / steps) * (Math.sin(curS) ** 2) * 2;
        this.updateTransformationMatrix();
        if (curS < Math.PI) {
          return requestAnimationFrame(step);
        } else if (callback) {
          return callback();
        }
      };
      return requestAnimationFrame(step);
    }

    // Moves an element relative to its current position.
    moveRelative(moveX, moveY, duration) {
      return this.move(this.matrix[12], this.matrix[13], this.matrix[12] + moveX, this.matrix[13] + moveY, duration);
    }

    // Updates the scale factor of @element over the course
    // of 400ms.
    scale(scale) {
      var curS, step, steps;
      steps = 400 / 16;
      curS = 0;
      step = () => {
        curS += Math.PI / steps;
        this.matrix[0] += (scale - this.matrix[0]) / steps;
        this.matrix[5] += (scale - this.matrix[0]) / steps;
        this.updateTransformationMatrix();
        if (curS < Math.PI) {
          return requestAnimationFrame(step);
        }
      };
      return requestAnimationFrame(step);
    }

    // Moves an element to a new position with the use
    // of an animationFrame.
    moveSingleFrame(moveX, moveY) {
      var moveAnimation;
      moveAnimation = () => {
        this.matrix[12] += moveX;
        this.matrix[13] += moveY;
        return this.updateTransformationMatrix();
      };
      return requestAnimationFrame(moveAnimation);
    }

    // Updates the transformation matrix on @element.
    updateTransformationMatrix() {
      return this.element.style.transform = "matrix3d(" + this.matrix.join(',') + ")";
    }

  };

  // Provides a simple interface to add click listeners
  // to all buttons.
  ClickHandler = class ClickHandler {
    // Initializes the variables pointing to all
    // objects that can be clicked.
    constructor() {
      this.resetPositionButton = document.getElementById("reset-position-button");
      this.privacyButton = document.getElementById("privacy-button");
      this.resetButton = document.getElementById("reset-button");
      this.zoomInButton = document.getElementById("zoom-in-button");
      this.zoomOutButton = document.getElementById("zoom-out-button");
    }

    // Binds all click listeners.
    startListening() {
      this.bindPrivacyButton();
      this.bindResetButton();
      this.bindResetPositionButton();
      return this.bindZoomButtons();
    }

    // Binds the buttons to zoom in and out on the mindmap.
    bindZoomButtons() {
      this.zoomInButton.addEventListener("click", function() {
        return fg.mindmap.zoomIn();
      });
      return this.zoomOutButton.addEventListener("click", function() {
        return fg.mindmap.zoomOut();
      });
    }

    // Displays or removes the privacy popup.
    bindPrivacyButton() {
      return this.privacyButton.addEventListener("click", () => {
        return fg.mindmap.showPrivacyPopup();
      });
    }

    // Resets the state of the mindmap.
    bindResetButton() {
      return this.resetButton.addEventListener("click", function() {
        return fg.mindmap.reset();
      });
    }

    // Resets the mindmap position on click.
    bindResetPositionButton() {
      return this.resetPositionButton.addEventListener("click", function() {
        return fg.mindmap.moveToCenter();
      });
    }

  };

  // Checks if the element or any of its parents has a specified class.
  recursiveHasClass = function(element, className) {
    while (element) {
      if (element.classList && element.classList.contains(className)) {
        return true;
      }
      element = element.parentNode;
    }
    return false;
  };

  // Returns the outerheight of an element.
  getOuterHeight = function(element) {
    var margin, styles;
    styles = window.getComputedStyle(element);
    margin = parseFloat(styles["marginTop"]) + parseFloat(styles["marginBottom"]);
    return Math.ceil(element.offsetHeight + margin);
  };

  // Checks if element a is a child of element b.
  isDescendant = function(a, b) {
    var node;
    node = a.parentNode;
    while (node !== null) {
      if (node === b) {
        return true;
      }
      node = node.parentNode;
    }
    return false;
  };

  // Calculate the width of a given string
  // using the invisible text-ruler element..
  measureTextWidth = function(text) {
    var ruler;
    ruler = document.querySelector("#text-ruler");
    ruler.innerHTML = text;
    return ruler.offsetWidth;
  };

  // Returns just the text of some html content.
  getText = function(html) {
    var block;
    block = document.createElement("div");
    block.innerHTML = html;
    return block.innerText; // Provides a simple interface to interact with the
  };

  // mindmap and its contents.
  Mindmap = class Mindmap {
    // Initializes the mindmap by loading all needed data.
    // Triggers the callback when the data is loaded.
    constructor(callback = false) {
      // Basic elements.
      this.container = document.getElementById("mindmap");
      this.rootNode = document.getElementById("rootnode");
      this.content = document.getElementById("content");
      this.privacyPopup = document.getElementById("privacy-popup");
      this.isMovingToCenter = false;
      // Animating and moving of the mindmap.
      this.animation = new Animation(this.container);
      // The zoom-level of the mindmap.
      this.zoomFactor = 1.0;
      this.loadData(callback);
    }

    // Uses an AJAX call to load the mindmap data.
    loadData(callback) {
      var httpRequest;
      httpRequest = new XMLHttpRequest();
      httpRequest.onreadystatechange = () => {
        if (httpRequest.readyState === XMLHttpRequest.DONE) {
          if (httpRequest.status === 200) {
            // Data is successfully loaded, so let's display it to the user.
            this.data = JSON.parse(httpRequest.responseText);
            this.createStudySelectBalloon();
            if (callback) {
              return callback();
            }
          } else {
            this.data = {};
            return console.error("Couldn't load the map data!");
          }
        }
      };
      httpRequest.open("GET", "data/content.json");
      return httpRequest.send();
    }

    // Updates the contents of the textbubble using a fade-in and
    // fade-out animation. Removes the old bubble from the DOM.
    updateTextBubbleContent(newContent) {
      var fadeInAnimation, fadeOutAnimation, i, len, newBubble, oldBubble, ref;
      ref = document.getElementsByClassName("textbubble");
      for (i = 0, len = ref.length; i < len; i++) {
        oldBubble = ref[i];
        if (oldBubble.innerText.replace(/^\s+|\s+|\n+$/gm, '') === newContent.innerText.replace(/^\s+|\s+|\n+$/gm, '')) {
          return;
        }
        oldBubble.addEventListener("animationend", function() {
          if (oldBubble.parentElement) {
            return oldBubble.parentElement.removeChild(oldBubble);
          }
        });
        oldBubble.addEventListener("webkitAnimationEnd", function() {
          if (oldBubble.parentElement) {
            return oldBubble.parentElement.removeChild(oldBubble);
          }
        });
        oldBubble.classList.add("bubbleFadeOut");
      }
      fadeOutAnimation = new Animation(oldBubble);
      newBubble = document.createElement("div");
      newBubble.className = "textbubble bubbleFadeIn";
      newBubble.appendChild(newContent);
      fadeInAnimation = new Animation(newBubble);
      return this.rootNode.appendChild(newBubble);
    }

    // Creates the balloon that allows the user to pick his or her
    // study and year.
    createStudySelectBalloon() {
      var disabledPlaceholder, i, len, ref, selectStudyLabel, studies, study, studySelectBalloon, studySelectContainer, yearSelectContainer;
      // Create the HTML for the study-select balloon.
      studySelectBalloon = document.createElement("span");
      studySelectBalloon.className = "textBubbleContent studySelect no-drag";
      // The text-label.
      selectStudyLabel = document.createElement("label");
      selectStudyLabel.innerHTML = "Kies je studie en studiejaar:";
      studySelectBalloon.appendChild(selectStudyLabel);
      // The study select-input.
      studySelectContainer = document.createElement("span");
      studySelectContainer.className = "dropdown";
      this.studySelect = document.createElement("select");
      this.studySelect.id = "studySelect";
      disabledPlaceholder = new Option("Selecteer je studie", null, true, true);
      disabledPlaceholder.disabled = true;
      disabledPlaceholder.classList.add("placeholder");
      this.studySelect.appendChild(disabledPlaceholder);
      studySelectContainer.appendChild(this.studySelect);
      studySelectBalloon.appendChild(studySelectContainer);
      // The year select-input.
      yearSelectContainer = document.createElement("span");
      yearSelectContainer.className = "dropdown";
      this.yearSelect = document.createElement("select");
      this.yearSelect.id = "yearSelect";
      this.yearSelect.disabled = true;
      disabledPlaceholder = new Option("Selecteer je studiejaar", null, true, true);
      disabledPlaceholder.classList.add("placeholder");
      disabledPlaceholder.disabled = true;
      this.yearSelect.appendChild(disabledPlaceholder);
      yearSelectContainer.appendChild(this.yearSelect);
      studySelectBalloon.appendChild(yearSelectContainer);
      // The submit-button.
      this.studySelectButton = document.createElement("button");
      this.studySelectButton.id = "studySelectButton";
      this.studySelectButton.innerHTML = "OK";
      this.studySelectButton.disabled = true;
      studySelectBalloon.appendChild(this.studySelectButton);
      // Load and sort all studynames.
      studies = Object.keys(this.data.studies);
      this.sortedStudies = studies.sort((a, b) => {
        var weightA, weightB;
        weightA = parseInt(this.data.studies[a].data.weight);
        weightB = parseInt(this.data.studies[b].data.weight);
        if (weightA > weightB) {
          return 1;
        }
        if (weightA < weightB) {
          return -1;
        }
        return 0;
      });
      ref = this.sortedStudies;
      // Insert the studies in the select-input.
      for (i = 0, len = ref.length; i < len; i++) {
        study = ref[i];
        this.studySelect.appendChild(new Option(study, studies.indexOf(study)));
      }
      // Add the eventlisteners.
      this.bindStudySelect();
      // Show the balloon.
      return this.updateTextBubbleContent(studySelectBalloon);
    }

    // Binds the eventlisteners that allow the user to pick and choose
    // their study and year.
    bindStudySelect() {
      var studyWeight;
      studyWeight = null;
      // Load all year options when a study is picked.
      this.studySelect.addEventListener("change", () => {
        var i, j, len, len1, oldOption, ref, sortedYearOptions, year, yearOptions, years;
        // Assure the ok-button is still disabled as it should be,
        // since picking a study still requires you to select a year.
        this.studySelectButton.disabled = true;
        studyWeight = parseInt(this.studySelect.value) + 1;
        years = this.data.studies[Object.keys(window.fg.mindmap.data.studies).find(key => window.fg.mindmap.data.studies[key].data.weight == studyWeight)].years;
        yearOptions = Object.keys(years);
        sortedYearOptions = yearOptions.concat().sort(function(a, b) {
          var weightA, weightB;
          weightA = parseInt(years[a].data.weight);
          weightB = parseInt(years[b].data.weight);
          if (weightA > weightB) {
            return 1;
          }
          if (weightA < weightB) {
            return -1;
          }
          return 0;
        });
        // If there are any options, enable the year selection and submit button.
        this.yearSelect.disabled = yearOptions.length === 0;
        ref = this.yearSelect.querySelectorAll("option:not([class='placeholder'])");
        // Remove all previous options.
        for (i = 0, len = ref.length; i < len; i++) {
          oldOption = ref[i];
          this.yearSelect.removeChild(oldOption);
        }
// Insert the new options.
        for (j = 0, len1 = sortedYearOptions.length; j < len1; j++) {
          year = sortedYearOptions[j];
          this.yearSelect.add(new Option(year, yearOptions.indexOf(year)));
        }
        // Set the default option back to the placeholder.
        return this.yearSelect.value = null;
      });
      // Enable the ok-button when a year has been selected.
      this.yearSelect.addEventListener("change", () => {
        return this.studySelectButton.disabled = false;
      });
      // Loads the selected study and year when the ok-button is pressed.
      return this.studySelectButton.addEventListener("click", () => {
        this.selectedStudy = Object.keys(window.fg.mindmap.data.studies).find(key => window.fg.mindmap.data.studies[key].data.weight == studyWeight);
        this.selectedYear = Object.keys(this.data.studies[this.selectedStudy]["years"])[this.yearSelect.value];
        this.mindmapData = this.data.studies[this.selectedStudy]["years"][this.selectedYear];
        return this.renderMindMap();
      });
    }

    // Renders the given mindmap data to the screen,
    // adding all click handlers on the way.
    renderMindMap() {
      var i, len, node, nodeData, sortedNodes, welcomeBubble;
      // Update the textbubble.
      welcomeBubble = document.createElement("span");
      welcomeBubble.className = "textBubbleContent standard";
      welcomeBubble.innerHTML = this.data.studies[this.selectedStudy].data.welcomeMessage;
      this.updateTextBubbleContent(welcomeBubble);
      // Create and render node-objects for every node.
      sortedNodes = this.mindmapData.nodes.sort(function(a, b) {
        var weightA, weightB;
        weightA = parseInt(a.weight);
        weightB = parseInt(b.weight);
        if (weightA > weightB) {
          return 1;
        }
        if (weightA < weightB) {
          return -1;
        }
        return 0;
      });
      for (i = 0, len = sortedNodes.length; i < len; i++) {
        nodeData = sortedNodes[i];
        node = new supportedNodeTypes[nodeData.type](nodeData, true);
        node.build().addListeners().render();
      }
      // Display the reset and show-all buttons.
      document.getElementById("reset-button").style.display = "inline-block";
      document.getElementById("reset-button").classList.add("fade-in");
      // Show the hint after 5 seconds.
      return setTimeout((() => {
        var hint;
        hint = document.querySelector("#hint");
        hint.classList.add("fade-in");
        return setTimeout((() => {
          hint.classList.remove("fade-in");
          hint.classList.add("fade-out");
          return hint.addEventListener("animationend", () => {
            return hint.parentElement.removeChild(hint);
          });
        }), 7000);
      }), 1000);
    }

    // Displays the privacy popup.
    showPrivacyPopup() {
      var removePopup;
      removePopup = () => {
        var animationEnd;
        animationEnd = () => {
          this.privacyPopup.style.display = "none";
          return this.privacyPopup.removeEventListener("animationend", animationEnd);
        };
        this.privacyPopup.addEventListener("animationend", animationEnd);
        this.privacyPopup.classList.remove("fade-in");
        this.privacyPopup.classList.add("fade-out");
        this.privacyPopup.querySelector("#accept-button").removeEventListener("click", removePopup);
        return this.removeOverlay();
      };
      this.showOverlay(removePopup);
      this.privacyPopup.style.display = "block";
      this.privacyPopup.classList.remove("fade-out");
      this.privacyPopup.classList.add("fade-in");
      return this.privacyPopup.querySelector("#accept-button").addEventListener("click", removePopup);
    }

    // Animates the mindmap moving to its center.
    moveToCenter() {
      var content, contentH, contentW, rootH, rootW, rootX, rootY, targetX, targetY;
      this.isMovingToCenter = true;
      content = document.querySelector("#content");
      contentW = content.getBoundingClientRect().width;
      contentH = content.getBoundingClientRect().height;
      rootW = this.rootNode.getBoundingClientRect().width;
      rootH = this.rootNode.getBoundingClientRect().height;
      targetX = Math.ceil(contentW - rootW) / 2;
      targetY = Math.ceil(contentH - rootH) / 2;
      rootX = Math.ceil(this.rootNode.getBoundingClientRect().left);
      rootY = Math.ceil(this.rootNode.getBoundingClientRect().top);
      return this.animation.move(rootX, rootY, targetX, targetY, 500, () => {
        return this.isMovingToCenter = false;
      });
    }

    // Resets the state of the mindmap.
    // Keeps the selected study and year.
    reset() {
      var checkbox, expandButton, i, j, k, len, len1, len2, node, progressBar, ref, ref1, ref2, resetMessage;
      if (this.container.querySelectorAll(".node-expand.active").length === 0) {
        this.moveToCenter();
      }
      ref = this.container.querySelectorAll(".root-child");
      // Unchecks all checkboxes, resets the progressbars and collapses
      // the checklist nodes and their subtrees.
      for (i = 0, len = ref.length; i < len; i++) {
        node = ref[i];
        ref1 = node.querySelectorAll("input[type='checkbox']");
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          checkbox = ref1[j];
          checkbox.checked = false;
        }
        ref2 = node.querySelectorAll(".bar");
        for (k = 0, len2 = ref2.length; k < len2; k++) {
          progressBar = ref2[k];
          progressBar.style.width = "0px";
        }
        if (node.querySelector(".node").classList.contains("active")) {
          node.querySelector(".node-content-header").click();
        }
        expandButton = node.querySelector(".node-expand");
        if (expandButton && expandButton.classList.contains("active")) {
          expandButton.click();
        }
      }
      // Updates the textbubble.
      if (this.data.studies[this.selectedStudy].data.resetMessage && this.data.studies[this.selectedStudy].data.resetMessage.length) {
        resetMessage = document.createElement("span");
        resetMessage.classList.add("textBubbleContent", "standard");
        resetMessage.innerHTML = this.data.studies[this.selectedStudy].data.resetMessage;
        return this.updateTextBubbleContent(resetMessage);
      }
    }

    // Displays a semi-transparent, dark overlay over the screen
    // to emphasize a popup.
    showOverlay(callback = false) {
      var overlay;
      overlay = document.createElement("div");
      overlay.id = "overlay";
      overlay.classList.add("fade-in");
      overlay.addEventListener("click", () => {
        if (callback) {
          callback();
        }
        return this.removeOverlay();
      });
      return this.content.appendChild(overlay);
    }

    // Removes the overlay from the screen.
    removeOverlay() {
      var overlay;
      overlay = this.content.querySelector("#overlay");
      overlay.classList.remove("fade-in");
      overlay.classList.add("fade-out");
      return overlay.addEventListener("animationend", () => {
        if (this.content.contains(overlay)) {
          return this.content.removeChild(overlay);
        }
      });
    }

    // Zooms out the mindmap by 0.25 at a time.
    // Has a minimum zoomfactor of 0.25.
    zoomOut() {
      this.zoomFactor = Math.max(this.zoomFactor - 0.25, 0.25);
      return this.animation.scale(this.zoomFactor);
    }

    // Zooms in the mindmap by 0.25 at a time.
    // Has a maximum zoomfactor of 2.0.
    zoomIn() {
      this.zoomFactor = Math.min(this.zoomFactor + 0.25, 2.0);
      return this.animation.scale(this.zoomFactor);
    }

  };

  // Provides a simple interface to enable the dragging
  // and panning of the mindmap content.
  PanHandler = class PanHandler {
    // Initializes the variables used to keep track
    // of the movement.
    constructor() {
      // Uses the new position of the mouse to move the content.
      this.drag = this.drag.bind(this);
      this.listening = false;
      this.dragging = false;
      this.previousMouseX = this.previousMouseY = 0;
      this.content = document.getElementById("content");
      this.mindmap = document.getElementById("mindmap");
    }

    // Starts listening for pan events.
    startListening() {
      this.listening = true;
      this.bindMouseDown();
      this.bindMouseUp();
      this.bindTouchDown();
      this.bindTouchUp();
      this.bindMouseMove();
      return this.bindTouchMove();
    }

    // Binds the mousedown handler so we know when
    // the dragging starts.
    bindMouseDown() {
      return this.content.addEventListener("mousedown", (event) => {
        var overlay;
        overlay = document.getElementById("overlay");
        if (this.listening && !recursiveHasClass(event.target, "no-drag") && event.target !== overlay && !isDescendant(event.target, overlay)) {
          event.preventDefault();
          this.dragging = true;
          this.previousMouseX = event.clientX;
          this.previousMouseY = event.clientY;
          return document.body.style.cursor = "move";
        }
      });
    }

    // Binds the mouseup handler so we know when
    // the dragging ends.
    bindMouseUp() {
      return this.content.addEventListener("mouseup", (event) => {
        this.dragging = false;
        event.preventDefault();
        return document.body.style.cursor = "default";
      });
    }

    // Binds the touchdown handler so we know when
    // the dragging starts.
    bindTouchDown() {
      return this.content.addEventListener("touchstart", (event) => {
        if (this.listening && !recursiveHasClass(event.target, "no-drag")) {
          event.preventDefault();
          this.dragging = true;
          this.previousMouseX = event.targetTouches[0].pageX;
          return this.previousMouseY = event.targetTouches[0].pageY;
        }
      });
    }

    // Binds the touchup handler so we know when
    // the dragging ends.
    bindTouchUp() {
      return this.content.addEventListener("touchup", (event) => {
        this.dragging = false;
        return event.preventDefault();
      });
    }

    // Binds the mousemove handler so we can detect
    // dragging motions.
    bindMouseMove() {
      return this.content.addEventListener("mousemove", (event) => {
        if (this.dragging && this.listening) {
          event.preventDefault();
          this.drag(event.clientX, event.clientY);
          this.previousMouseX = event.clientX;
          return this.previousMouseY = event.clientY;
        }
      });
    }

    // Binds the touchmove handler so we can detect
    // dragging motions.
    bindTouchMove() {
      return this.content.addEventListener("touchmove", (event) => {
        if (this.dragging && this.listening) {
          event.preventDefault();
          this.drag(event.targetTouches[0].pageX, event.targetTouches[0].pageY);
          this.previousMouseX = event.targetTouches[0].pageX;
          return this.previousMouseY = event.targetTouches[0].pageY;
        }
      });
    }

    drag(currentMouseX, currentMouseY) {
      var movementX, movementY;
      movementX = currentMouseX - this.previousMouseX;
      movementY = currentMouseY - this.previousMouseY;
      return fg.mindmap.animation.moveSingleFrame(movementX, movementY);
    }

  };

  // Used to give unique IDs to all nodes.
  nodeCounter = 0;

  BaseNode = (function() {
    // Implements the basic methods and interface for every type of node.
    // Provides dynamic node construction, eventlisteners and the basic
    // behaviour of every node.
    class BaseNode {
      // Sets the basic properties of the node.
      constructor(nodeData1, isRootNode = false) {
        // The click-listener which filters out events for child-nodes
        // and passes the event to the @onClickEvent and optional
        // external event listeners.
        this.clickListener = this.clickListener.bind(this);
        this.nodeData = nodeData1;
        this.isRootNode = isRootNode;
      }

      /* PUBLIC METHODS */
      // Builds the basic DOM node-object on which all types of nodes
      // are based.
      build() {
        this.createDOMElement();
        this.expanded = false;
        return this;
      }

      // Renders the created node by appending it to the DOM.
      render() {
        if (this.isRootNode) {
          this.targetParent = document.getElementById(`${this.nodeData.side}branch`);
        } else {
          this.targetParent = this.nodeData.parent.querySelector(".children.nested");
        }
        this.targetParent.appendChild(this.html);
        this.nodeData.element = this.html;
        this.setNodeSize();
        return this;
      }

      // Renders the node with an slide-in animation.
      renderAnimated() {
        this.html.classList.add("animate-in");
        this.render();
        return this;
      }

      // Re-renders the node in its current location.
      rerender() {
        var node, pageNode, swapContents, transitionEnd, wasOpened;
        pageNode = this.targetParent.querySelector(`#${this.html.id}`);
        node = pageNode.querySelector(".node");
        wasOpened = false;
        swapContents = () => {
          // Transfer classes and contents.
          if (pageNode.querySelector(".node-expand")) {
            this.html.querySelector(".node-expand").className = pageNode.querySelector(".node-expand").className;
          }
          this.html.removeChild(this.html.querySelector(".children.nested"));
          this.html.appendChild(pageNode.querySelector(".children.nested"));
          pageNode.className = this.html.className;
          this.html.querySelector(".node").className = pageNode.querySelector(".node").className;
          pageNode.innerHTML = "";
          pageNode.appendChild(this.html.querySelector(".node"));
          pageNode.appendChild(this.html.querySelector(".children.nested"));
          this.html = pageNode;
          this.setNodeSize();
          if (wasOpened) {
            return this.activateNode(this.html.querySelector(".node"));
          }
        };
        if (node.classList.contains("active")) {
          wasOpened = true;
          transitionEnd = function() {
            node.removeEventListener("transitionend", transitionEnd);
            return swapContents();
          };
          node.addEventListener("transitionend", transitionEnd);
          this.deactivateNode(node);
        } else {
          swapContents();
        }
        return this;
      }

      // Binds all required listeners for this node.
      // The listeners pass on the events to the right event-handler method.
      addListeners() {
        this.html.removeEventListener("click", this.clickListener);
        this.html.addEventListener("click", this.clickListener);
        this.bindHoverListeners();
        if (this.nodeData.children && this.nodeData.children.length) {
          this.bindExpansionHandler();
        }
        return this;
      }

      // Places focus on this node by moving it to the center.
      focus() {
        var expandButton, focusX, focusY, moveX, moveY;
        expandButton = this.html.querySelector(".node-expand");
        focusX = Math.ceil(document.getElementById("content").offsetWidth / 2 - expandButton.offsetWidth / 2);
        focusY = Math.ceil(document.getElementById("content").offsetHeight / 2 - expandButton.offsetHeight / 2);
        moveX = focusX - expandButton.getBoundingClientRect().left;
        moveY = focusY - expandButton.getBoundingClientRect().top;
        fg.mindmap.animation.moveRelative(moveX, moveY, 500);
        return this;
      }

      // Removes focus from this node by focussing on its parent-node.
      blur() {
        var expandButton, focusAnimation, focusX, focusY, moveX, moveY;
        if (this.isRootNode && !fg.mindmap.isMovingToCenter) {
          fg.mindmap.moveToCenter();
        } else if (this.nodeData.parent) {
          focusAnimation = new Animation(document.querySelector("#mindmap"));
          expandButton = this.nodeData.parent.querySelector(".node-expand");
          focusX = Math.ceil(document.getElementById("content").offsetWidth / 2 - expandButton.offsetWidth / 2);
          focusY = Math.ceil(document.getElementById("content").offsetHeight / 2 - expandButton.offsetHeight / 2);
          moveX = focusX - expandButton.getBoundingClientRect().left;
          moveY = focusY - expandButton.getBoundingClientRect().top;
          fg.mindmap.animation.moveRelative(moveX, moveY, 500);
        }
        return this;
      }

      // Adds the expand-button if the node didn't have one yet.
      addExpandButton() {
        this.html.querySelector(".node-content").appendChild(this.buildExpandButton());
        return this.bindExpansionHandler();
      }

      /* PRIVATE METHODS */
      // Opens the node to show its full contents.
      activateNode(node) {
        var activeContentHeight, contentHeight, contentWidth, message, moveX, moveY, nodeRect, target, targetX, targetY;
        node.classList.add("active");
        target = node.querySelector(".node-content");
        // Focus the screen on the opening node if the node is too
        // far off center.
        contentWidth = document.getElementById("content").offsetWidth;
        contentHeight = document.getElementById("content").offsetHeight;
        nodeRect = target.getBoundingClientRect();
        if ((nodeRect.x + nodeRect.width) > 0.75 * contentWidth || (nodeRect.y + nodeRect.height) > 0.75 * contentHeight || (nodeRect.x < 0.25 * contentWidth) || (nodeRect.y < 0.25 * contentHeight)) {
          targetX = contentWidth / 2 - nodeRect.width / 2;
          targetY = contentHeight / 2 - nodeRect.height / 2;
          moveX = targetX - nodeRect.left;
          moveY = targetY - nodeRect.top;
          fg.mindmap.animation.moveRelative(moveX, moveY, 500);
        }
        // Open the new node.
        this.originalHeight = this.originalHeight || getOuterHeight(target);
        activeContentHeight = getOuterHeight(target.getElementsByClassName("node-active-content")[0]);
        node.style.height = `${this.originalHeight + activeContentHeight}px`;
        // If set, show the open-message.
        if (getText(this.nodeData.messages.open) && getText(this.nodeData.messages.open).length > 0) {
          message = document.createElement("span");
          message.className = "textBubbleContent standard";
          message.innerHTML = this.nodeData.messages.open;
          return fg.mindmap.updateTextBubbleContent(message);
        }
      }

      // Closes the node to go back to its original height.
      deactivateNode(node) {
        var message;
        node.classList.remove("active");
        node.style.height = `${this.originalHeight}px`;
        // If set, show the close-message.
        if (getText(this.nodeData.messages.close) && getText(this.nodeData.messages.close).length > 0) {
          message = document.createElement("span");
          message.className = "textBubbleContent standard";
          message.innerHTML = this.nodeData.messages.close;
          return fg.mindmap.updateTextBubbleContent(message);
        }
      }

      // Expands or minimizes the node on a user-click.
      // Can be extended by inheriting classes to handle click-events
      // with other purposes.
      onClickEvent(event) {
        var node, target;
        // Skip actions on elements that have non-default actions, such as checkboxes.
        if (recursiveHasClass(event.target, "prevent-default")) {
          return;
        }
        // Skip actions on elements that by default have their own actions,
        // such as links and buttons.
        if (["A", "BUTTON"].includes(event.target.tagName)) {
          return;
        }
        target = event.target.closest(".node-content");
        // Skip if the node itself wasn't clicked.
        if (target === null) {
          return;
        }
        node = target.closest(".node");
        // Toggle the size of the node.
        if (node.classList.contains("active")) {
          this.deactivateNode(node);
        } else {
          this.activateNode(node);
        }
      }

      // Creates the basic DOM element on which every node is based
      // and stores it in @html.
      createDOMElement() {
        var activeContent, arrow, chevron, childrenContainer, cleanedName, content, contentContainer, header, name, node, nodeContainer, nodeID, rule, target;
        if (typeof this.html !== "undefined") {
          nodeID = this.html.id;
        } else {
          nodeID = `node-${nodeCounter++}`;
        }
        // Create all HTML elements.
        nodeContainer = document.createElement("li");
        nodeContainer.id = nodeID;
        nodeContainer.classList.add("child-item");
        if (this.isRootNode) {
          nodeContainer.classList.add("root-child");
        }
        node = document.createElement("div");
        node.classList.add("node", "no-drag");
        node.style.backgroundColor = this.nodeData.color;
        contentContainer = document.createElement("div");
        contentContainer.classList.add("node-content-container");
        header = document.createElement("div");
        header.classList.add("node-content-header");
        content = document.createElement("div");
        content.classList.add("node-content");
        name = document.createElement("div");
        name.classList.add("node-name");
        name.innerHTML = this.nodeData.name;
        cleanedName = document.createElement("div");
        cleanedName.innerHTML = this.nodeData.name;
        name.style.width = `${measureTextWidth(cleanedName.innerText)}px`;
        activeContent = document.createElement("div");
        activeContent.classList.add("node-active-content");
        childrenContainer = document.createElement("ol");
        childrenContainer.classList.add("children", "nested");
        // Add the expand-arrow for child-nodes.
        if (this.nodeData.children && this.nodeData.children.length) {
          content.appendChild(this.buildExpandButton());
        }
        // Style the colored lines that run to the node.
        target = `#${nodeID}.child-item,#leftbranch #${nodeID}.child-item:before,#rightbranch #${nodeID}.child-item:before`;
        rule = `border-color: ${this.nodeData.color}`;
        document.styleSheets[0].addRule(target, rule);
        // Add the open/close arrow.
        arrow = document.createElement("div");
        arrow.classList.add("node-arrow");
        chevron = document.createElement("i");
        chevron.classList.add("fa", "fa-chevron-right");
        arrow.appendChild(chevron);
        // Put all the HTML elements together.
        header.appendChild(name);
        header.appendChild(arrow);
        contentContainer.appendChild(header);
        contentContainer.appendChild(activeContent);
        content.appendChild(contentContainer);
        node.appendChild(content);
        nodeContainer.appendChild(node);
        nodeContainer.appendChild(childrenContainer);
        this.html = nodeContainer;
      }

      clickListener(event) {
        var blockedByExternalListener, childContainer, externalListener, i, len, ref;
        childContainer = this.html.querySelector(".children.nested");
        // Filter out any events on children of this node.
        if (!isDescendant(event.target, childContainer)) {
          blockedByExternalListener = false;
          // Notify all external clicklisteners, such as the editor.
          if (this.externalClickListeners) {
            ref = this.externalClickListeners;
            for (i = 0, len = ref.length; i < len; i++) {
              externalListener = ref[i];
              blockedByExternalListener |= externalListener(this, event);
            }
          }
          // And then notify the internal listener.
          if (!blockedByExternalListener) {
            return this.onClickEvent(event);
          }
        }
      }

      // Binds the hover-listeners used for visual indications
      // such as the striped border.
      bindHoverListeners() {
        var container, expandButton, node;
        node = this.html.querySelector(".node");
        container = this.html.querySelector(".node-content-container");
        expandButton = this.html.querySelector(".node-expand");
        // The hover-effect on the node itself.
        container.addEventListener("mouseover", () => {
          return node.classList.add("hover");
        });
        container.addEventListener("mouseout", () => {
          return node.classList.remove("hover");
        });
        // The hover-effect on the expand-button.
        if (expandButton) {
          expandButton.addEventListener("mouseover", () => {
            return expandButton.classList.add("hover");
          });
          return expandButton.addEventListener("mouseout", () => {
            return expandButton.classList.remove("hover");
          });
        }
      }

      // Binds the expansionhandler that allows the user to expand
      // a sub-branch of this node and see it's child-nodes.
      bindExpansionHandler() {
        var expandButton;
        expandButton = this.html.querySelector(".node-expand");
        return expandButton.addEventListener("click", (event) => {
          // Toggle the child-container.
          expandButton.classList.toggle("active");
          this.expanded = !this.expanded;
          if (this.expanded) {
            this.expandChildren();
          } else {
            this.collapseChildren();
          }
        });
      }

      // Expands the child-nodes of the node.
      expandChildren() {
        var child, childNode, i, len, sortedChildren;
        sortedChildren = this.nodeData.children.sort(function(a, b) {
          if (a.weight > b.weight) {
            return 1;
          }
          if (a.weight < b.weight) {
            return -1;
          }
          return 0;
        });
        for (i = 0, len = sortedChildren.length; i < len; i++) {
          child = sortedChildren[i];
          // Extend the child-node with data from the parent-node.
          child.parent = this.html;
          child.parentObject = this;
          child.side = this.nodeData.side;
          childNode = new supportedNodeTypes[child.type](child);
          childNode.build().addListeners().renderAnimated();
        }
        // Place focus on the node.
        return this.focus();
      }

      // Collapse the child-nodes of the node.
      collapseChildren() {
        var child, childContainer, children, i, index, len;
        childContainer = this.html.querySelector(".children.nested");
        children = childContainer.querySelectorAll(".child-item");
        for (index = i = 0, len = children.length; i < len; index = ++i) {
          child = children[index];
          child.classList.add("animate-out");
          if (index === children.length - 1) {
            child.addEventListener("animationend", function() {
              return childContainer.innerHTML = "";
            });
          }
        }
        // Place focus on the node's parent.
        return this.blur();
      }

      // Sets the node-width correctly in absolute number of pixels so that the hover-border
      // has the correct size.
      // Not the most beautiful solution, but this can't be calculated in the build-function
      // since the browser doesn't know the real size of an element until its rendered.
      setNodeSize() {
        return this.html.querySelector(".node").style.width = `${(this.html.querySelector(".node-content-container").offsetWidth)}px`;
      }

      // Simply builds and returns the HTML element for the expand-button
      // so it can be appended to the node.
      buildExpandButton() {
        var chevron, nodeExpand, pipe;
        // Create the HTML elements.
        nodeExpand = document.createElement("div");
        nodeExpand.classList.add("node-expand", "prevent-default");
        nodeExpand.style.backgroundColor = this.nodeData.color;
        chevron = document.createElement("div");
        chevron.classList.add("chevron", this.nodeData.side);
        pipe = document.createElement("div");
        pipe.classList.add("pipe");
        // And combine them.
        nodeExpand.appendChild(chevron);
        nodeExpand.appendChild(pipe);
        return nodeExpand;
      }

    };

    // Keeps track of external clicklisteners that can subscribe
    // to click-events on this node, such as the editor.
    BaseNode.externalClickListeners = [];

    return BaseNode;

  }).call(this);

  // A simple checklist with progressbar to reflect on
  // the number of checkboxes checked.
  ChecklistNode = class ChecklistNode extends BaseNode {
    // Extends the basic node-HTML with checklist-specific extra's.
    build() {
      var bar, checkbox, checklist, checklistID, checkmark, i, item, label, len, progressbar, ref, rule, target, theorem;
      // Create the base node-html.
      super.build();
      // And extend it to a checklist node.
      this.html.classList.add("checklist");
      // Add the progressbar.
      progressbar = document.createElement("div");
      progressbar.classList.add("node-checklist-progressbar");
      bar = document.createElement("div");
      bar.classList.add("bar");
      progressbar.appendChild(bar);
      this.html.querySelector(".node-content-container").appendChild(progressbar);
      // Add the actual checklist.
      checklist = document.createElement("ul");
      checklistID = this.html.id;
      target = `#${checklistID} .checkmark:after`;
      rule = `border-style:solid!important;border-color:${this.nodeData.color}!important;border-image:initial!important;border-width: 0 3px 3px 0 !important;`;
      if (navigator.userAgent.toLowerCase().indexOf('firefox') > -1) {
        document.styleSheets[0].insertRule(`${target} {${rule}}`);
      } else {
        document.styleSheets[0].addRule(target, rule);
      }
      ref = this.nodeData.data.theorems;
      for (i = 0, len = ref.length; i < len; i++) {
        theorem = ref[i];
        item = document.createElement("li");
        item.classList.add("checkbox-item", "prevent-default");
        label = document.createElement("label");
        label.classList.add("container");
        label.innerHTML = theorem;
        checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkmark = document.createElement("div");
        checkmark.classList.add("checkmark", checklistID);
        label.appendChild(checkbox);
        label.appendChild(checkmark);
        item.appendChild(label);
        checklist.appendChild(item);
      }
      this.html.querySelector(".node-active-content").appendChild(checklist);
      return this;
    }

    // Adds eventlisteners for the checkboxes that update the progressbar
    // when the user checks one or more checkboxes.
    onClickEvent(event) {
      var allCheckboxes, bar, checkedCheckboxes, expandButton, feedback, i, len, parent, percentage, percentageChecked, ref, results, target;
      // Process normal click-events first.
      super.onClickEvent(event);
      // Skip the event if this is no checkbox.
      if (!recursiveHasClass(event.target, "checkbox-item")) {
        return;
      }
      target = event.target;
      parent = target.closest(".node");
      bar = parent.querySelector(".bar");
      // Calculate the percentage of checked checkboxes.
      checkedCheckboxes = parent.querySelectorAll("input[type='checkbox']:checked").length;
      allCheckboxes = parent.querySelectorAll("input[type='checkbox']").length;
      percentageChecked = Math.ceil(checkedCheckboxes / allCheckboxes * 100);
      // And update the progressbar.
      bar.style.width = `${percentageChecked}%`;
      // Assure the subtree is expanded if two or more
      // checkboxes are checked.
      if (checkedCheckboxes >= 2) {
        expandButton = parent.querySelector(".node-expand");
        if (expandButton && !(expandButton.classList.contains("active"))) {
          expandButton.click();
        }
      }
      ref = Object.keys(this.nodeData.data.feedback).reverse();
      // Place optional feedback in the textbubble.
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        percentage = ref[i];
        if (percentageChecked >= percentage) {
          feedback = document.createElement("span");
          feedback.classList.add("textBubbleContent", "standard");
          feedback.innerHTML = this.nodeData.data.feedback[percentage];
          fg.mindmap.updateTextBubbleContent(feedback);
          break;
        } else {
          results.push(void 0);
        }
      }
      return results;
    }

  };

  TextNode = class TextNode extends BaseNode {
    // Extends the basic node-HTML with textnode-specific extra's.
    build() {
      // Create the base node-html.
      super.build();
      this.html.classList.add("text");
      this.html.querySelector(".node-active-content").innerHTML = this.nodeData.data.text;
      return this;
    }

  };

  VideoNode = class VideoNode extends BaseNode {
    // Extends the basic node-HTML with videonode-specific extra's.
    build() {
      var text, video;
      // Create the base node-html.
      super.build();
      this.html.classList.add("video");
      // If set, add text to be displayed above the video.
      if (this.nodeData.data.text) {
        text = document.createElement("div");
        text.classList.add("text");
        text.innerHTML = this.nodeData.data.text;
        this.html.querySelector(".node-active-content").appendChild(text);
      }
      if (this.nodeData.data.url) {
        this.open = false;
        video = document.createElement("iframe");
        video.frameborder = 0;
        video.setAttribute("allowfullscreen", "");
        video.setAttribute("mozallowfullscreen", "");
        video.setAttribute("msallowfullscreen", "");
        video.setAttribute("oallowfullscreen", "");
        video.setAttribute("webkitallowfullscreen", "");
        video.classList.add("frame");
        this.html.querySelector(".node-active-content").appendChild(video);
      }
      return this;
    }

    activateNode() {
      super.activateNode(this.html.querySelector(".node"));
      if (!this.open) {
        this.html.querySelector("iframe").src = this.nodeData.data.url;
        return this.open = true;
      }
    }

  };

  // Supported node-types.
  supportedNodeTypes = {
    "checklist": ChecklistNode,
    "text": TextNode,
    "video": VideoNode
  };

  window.fg = {};

  document.addEventListener("DOMContentLoaded", function(event) {
    fg.mindmap = new Mindmap;
    fg.panHandler = new PanHandler;
    fg.clickHandler = new ClickHandler;
    fg.panHandler.startListening();
    return fg.clickHandler.startListening();
  });

}).call(this);
