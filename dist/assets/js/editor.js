// Generated by CoffeeScript 2.4.1
(function() {
  // Provides an easy way to animate movement of
  // DOM objects.
  var Animation, BaseNode, ChecklistNode, ClickHandler, EDITABLE_PROPERTIES, Editor, Mindmap, NORMALIZED_NAMES, PROPERTY_TYPES, PanHandler, SideMenu, TextNode, VideoNode, getOuterHeight, getText, isDescendant, measureTextWidth, nodeCounter, recursiveHasClass, supportedNodeTypes,
    indexOf = [].indexOf;

  Animation = class Animation {
    // Sets the element to animate.
    constructor(element1) {
      this.element = element1;
      this.matrix = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    }

    // Moving animation to move an element from a given position
    // to a target position over the course of 'durationMS' ms.
    move(fromX, fromY, toX, toY, durationMS, callback = false) {
      var curS, step, steps;
      steps = durationMS / 16;
      curS = 0;
      step = () => {
        curS += Math.PI / steps;
        this.matrix[12] += ((toX - fromX) / steps) * (Math.sin(curS) ** 2) * 2;
        this.matrix[13] += ((toY - fromY) / steps) * (Math.sin(curS) ** 2) * 2;
        this.updateTransformationMatrix();
        if (curS < Math.PI) {
          return requestAnimationFrame(step);
        } else if (callback) {
          return callback();
        }
      };
      return requestAnimationFrame(step);
    }

    // Moves an element relative to its current position.
    moveRelative(moveX, moveY, duration) {
      return this.move(this.matrix[12], this.matrix[13], this.matrix[12] + moveX, this.matrix[13] + moveY, duration);
    }

    // Updates the scale factor of @element over the course
    // of 400ms.
    scale(scale) {
      var curS, step, steps;
      steps = 400 / 16;
      curS = 0;
      step = () => {
        curS += Math.PI / steps;
        this.matrix[0] += (scale - this.matrix[0]) / steps;
        this.matrix[5] += (scale - this.matrix[0]) / steps;
        this.updateTransformationMatrix();
        if (curS < Math.PI) {
          return requestAnimationFrame(step);
        }
      };
      return requestAnimationFrame(step);
    }

    // Moves an element to a new position with the use
    // of an animationFrame.
    moveSingleFrame(moveX, moveY) {
      var moveAnimation;
      moveAnimation = () => {
        this.matrix[12] += moveX;
        this.matrix[13] += moveY;
        return this.updateTransformationMatrix();
      };
      return requestAnimationFrame(moveAnimation);
    }

    // Updates the transformation matrix on @element.
    updateTransformationMatrix() {
      return this.element.style.transform = "matrix3d(" + this.matrix.join(',') + ")";
    }

  };

  // Provides a simple interface to add click listeners
  // to all buttons.
  ClickHandler = class ClickHandler {
    // Initializes the variables pointing to all
    // objects that can be clicked.
    constructor() {
      this.resetPositionButton = document.getElementById("reset-position-button");
      this.privacyButton = document.getElementById("privacy-button");
      this.resetButton = document.getElementById("reset-button");
      this.zoomInButton = document.getElementById("zoom-in-button");
      this.zoomOutButton = document.getElementById("zoom-out-button");
    }

    // Binds all click listeners.
    startListening() {
      this.bindPrivacyButton();
      this.bindResetButton();
      this.bindResetPositionButton();
      return this.bindZoomButtons();
    }

    // Binds the buttons to zoom in and out on the mindmap.
    bindZoomButtons() {
      this.zoomInButton.addEventListener("click", function() {
        return fg.mindmap.zoomIn();
      });
      return this.zoomOutButton.addEventListener("click", function() {
        return fg.mindmap.zoomOut();
      });
    }

    // Displays or removes the privacy popup.
    bindPrivacyButton() {
      return this.privacyButton.addEventListener("click", () => {
        return fg.mindmap.showPrivacyPopup();
      });
    }

    // Resets the state of the mindmap.
    bindResetButton() {
      return this.resetButton.addEventListener("click", function() {
        return fg.mindmap.reset();
      });
    }

    // Resets the mindmap position on click.
    bindResetPositionButton() {
      return this.resetPositionButton.addEventListener("click", function() {
        return fg.mindmap.moveToCenter();
      });
    }

  };

  // Checks if the element or any of its parents has a specified class.
  recursiveHasClass = function(element, className) {
    while (element) {
      if (element.classList && element.classList.contains(className)) {
        return true;
      }
      element = element.parentNode;
    }
    return false;
  };

  // Returns the outerheight of an element.
  getOuterHeight = function(element) {
    var margin, styles;
    styles = window.getComputedStyle(element);
    margin = parseFloat(styles["marginTop"]) + parseFloat(styles["marginBottom"]);
    return Math.ceil(element.offsetHeight + margin);
  };

  // Checks if element a is a child of element b.
  isDescendant = function(a, b) {
    var node;
    node = a.parentNode;
    while (node !== null) {
      if (node === b) {
        return true;
      }
      node = node.parentNode;
    }
    return false;
  };

  // Calculate the width of a given string
  // using the invisible text-ruler element..
  measureTextWidth = function(text) {
    var ruler;
    ruler = document.querySelector("#text-ruler");
    ruler.innerHTML = text;
    return ruler.offsetWidth;
  };

  // Returns just the text of some html content.
  getText = function(html) {
    var block;
    block = document.createElement("div");
    block.innerHTML = html;
    return block.innerText; // Provides a simple interface to interact with the
  };

  // mindmap and its contents.
  Mindmap = class Mindmap {
    // Initializes the mindmap by loading all needed data.
    // Triggers the callback when the data is loaded.
    constructor(callback = false) {
      // Basic elements.
      this.container = document.getElementById("mindmap");
      this.rootNode = document.getElementById("rootnode");
      this.content = document.getElementById("content");
      this.privacyPopup = document.getElementById("privacy-popup");
      this.isMovingToCenter = false;
      // Animating and moving of the mindmap.
      this.animation = new Animation(this.container);
      // The zoom-level of the mindmap.
      this.zoomFactor = 1.0;
      this.loadData(callback);
    }

    // Uses an AJAX call to load the mindmap data.
    loadData(callback) {
      var httpRequest;
      httpRequest = new XMLHttpRequest();
      httpRequest.onreadystatechange = () => {
        if (httpRequest.readyState === XMLHttpRequest.DONE) {
          if (httpRequest.status === 200) {
            // Data is successfully loaded, so let's display it to the user.
            this.data = JSON.parse(httpRequest.responseText);
            this.createStudySelectBalloon();
            if (callback) {
              return callback();
            }
          } else {
            this.data = {};
            return console.error("Couldn't load the map data!");
          }
        }
      };
      httpRequest.open("GET", "data/content.json");
      return httpRequest.send();
    }

    // Updates the contents of the textbubble using a fade-in and
    // fade-out animation. Removes the old bubble from the DOM.
    updateTextBubbleContent(newContent) {
      var fadeInAnimation, fadeOutAnimation, i, len, newBubble, oldBubble, ref;
      ref = document.getElementsByClassName("textbubble");
      for (i = 0, len = ref.length; i < len; i++) {
        oldBubble = ref[i];
        if (oldBubble.innerText.replace(/^\s+|\s+|\n+$/gm, '') === newContent.innerText.replace(/^\s+|\s+|\n+$/gm, '')) {
          return;
        }
        oldBubble.addEventListener("animationend", function() {
          if (oldBubble.parentElement) {
            return oldBubble.parentElement.removeChild(oldBubble);
          }
        });
        oldBubble.addEventListener("webkitAnimationEnd", function() {
          if (oldBubble.parentElement) {
            return oldBubble.parentElement.removeChild(oldBubble);
          }
        });
        oldBubble.classList.add("bubbleFadeOut");
      }
      fadeOutAnimation = new Animation(oldBubble);
      newBubble = document.createElement("div");
      newBubble.className = "textbubble bubbleFadeIn";
      newBubble.appendChild(newContent);
      fadeInAnimation = new Animation(newBubble);
      return this.rootNode.appendChild(newBubble);
    }

    // Creates the balloon that allows the user to pick his or her
    // study and year.
    createStudySelectBalloon() {
      var disabledPlaceholder, i, len, ref, selectStudyLabel, studies, study, studySelectBalloon, studySelectContainer, yearSelectContainer;
      // Create the HTML for the study-select balloon.
      studySelectBalloon = document.createElement("span");
      studySelectBalloon.className = "textBubbleContent studySelect no-drag";
      // The text-label.
      selectStudyLabel = document.createElement("label");
      selectStudyLabel.innerHTML = "Kies je studie en studiejaar:";
      studySelectBalloon.appendChild(selectStudyLabel);
      // The study select-input.
      studySelectContainer = document.createElement("span");
      studySelectContainer.className = "dropdown";
      this.studySelect = document.createElement("select");
      this.studySelect.id = "studySelect";
      disabledPlaceholder = new Option("Selecteer je studie", null, true, true);
      disabledPlaceholder.disabled = true;
      disabledPlaceholder.classList.add("placeholder");
      this.studySelect.appendChild(disabledPlaceholder);
      studySelectContainer.appendChild(this.studySelect);
      studySelectBalloon.appendChild(studySelectContainer);
      // The year select-input.
      yearSelectContainer = document.createElement("span");
      yearSelectContainer.className = "dropdown";
      this.yearSelect = document.createElement("select");
      this.yearSelect.id = "yearSelect";
      this.yearSelect.disabled = true;
      disabledPlaceholder = new Option("Selecteer je studiejaar", null, true, true);
      disabledPlaceholder.classList.add("placeholder");
      disabledPlaceholder.disabled = true;
      this.yearSelect.appendChild(disabledPlaceholder);
      yearSelectContainer.appendChild(this.yearSelect);
      studySelectBalloon.appendChild(yearSelectContainer);
      // The submit-button.
      this.studySelectButton = document.createElement("button");
      this.studySelectButton.id = "studySelectButton";
      this.studySelectButton.innerHTML = "OK";
      this.studySelectButton.disabled = true;
      studySelectBalloon.appendChild(this.studySelectButton);
      // Load and sort all studynames.
      studies = Object.keys(this.data.studies);
      this.sortedStudies = studies.sort((a, b) => {
        var weightA, weightB;
        weightA = parseInt(this.data.studies[a].data.weight);
        weightB = parseInt(this.data.studies[b].data.weight);
        if (weightA > weightB) {
          return 1;
        }
        if (weightA < weightB) {
          return -1;
        }
        return 0;
      });
      ref = this.sortedStudies;
      // Insert the studies in the select-input.
      for (i = 0, len = ref.length; i < len; i++) {
        study = ref[i];
        this.studySelect.appendChild(new Option(study, studies.indexOf(study)));
      }
      // Add the eventlisteners.
      this.bindStudySelect();
      // Show the balloon.
      return this.updateTextBubbleContent(studySelectBalloon);
    }

    // Binds the eventlisteners that allow the user to pick and choose
    // their study and year.
    bindStudySelect() {
      var studyWeight;
      studyWeight = null;
      // Load all year options when a study is picked.
      this.studySelect.addEventListener("change", () => {
        var i, j, len, len1, oldOption, ref, sortedYearOptions, year, yearOptions, years;
        // Assure the ok-button is still disabled as it should be,
        // since picking a study still requires you to select a year.
        this.studySelectButton.disabled = true;
        studyWeight = parseInt(this.studySelect.value) + 1;
        years = this.data.studies[Object.keys(window.fg.mindmap.data.studies).find(key => window.fg.mindmap.data.studies[key].data.weight == studyWeight)].years;
        yearOptions = Object.keys(years);
        sortedYearOptions = yearOptions.concat().sort(function(a, b) {
          var weightA, weightB;
          weightA = parseInt(years[a].data.weight);
          weightB = parseInt(years[b].data.weight);
          if (weightA > weightB) {
            return 1;
          }
          if (weightA < weightB) {
            return -1;
          }
          return 0;
        });
        // If there are any options, enable the year selection and submit button.
        this.yearSelect.disabled = yearOptions.length === 0;
        ref = this.yearSelect.querySelectorAll("option:not([class='placeholder'])");
        // Remove all previous options.
        for (i = 0, len = ref.length; i < len; i++) {
          oldOption = ref[i];
          this.yearSelect.removeChild(oldOption);
        }
// Insert the new options.
        for (j = 0, len1 = sortedYearOptions.length; j < len1; j++) {
          year = sortedYearOptions[j];
          this.yearSelect.add(new Option(year, yearOptions.indexOf(year)));
        }
        // Set the default option back to the placeholder.
        return this.yearSelect.value = null;
      });
      // Enable the ok-button when a year has been selected.
      this.yearSelect.addEventListener("change", () => {
        return this.studySelectButton.disabled = false;
      });
      // Loads the selected study and year when the ok-button is pressed.
      return this.studySelectButton.addEventListener("click", () => {
        this.selectedStudy = Object.keys(window.fg.mindmap.data.studies).find(key => window.fg.mindmap.data.studies[key].data.weight == studyWeight);
        this.selectedYear = Object.keys(this.data.studies[this.selectedStudy]["years"])[this.yearSelect.value];
        this.mindmapData = this.data.studies[this.selectedStudy]["years"][this.selectedYear];
        return this.renderMindMap();
      });
    }

    // Renders the given mindmap data to the screen,
    // adding all click handlers on the way.
    renderMindMap() {
      var i, len, node, nodeData, sortedNodes, welcomeBubble;
      // Update the textbubble.
      welcomeBubble = document.createElement("span");
      welcomeBubble.className = "textBubbleContent standard";
      welcomeBubble.innerHTML = this.data.studies[this.selectedStudy].data.welcomeMessage;
      this.updateTextBubbleContent(welcomeBubble);
      // Create and render node-objects for every node.
      sortedNodes = this.mindmapData.nodes.sort(function(a, b) {
        var weightA, weightB;
        weightA = parseInt(a.weight);
        weightB = parseInt(b.weight);
        if (weightA > weightB) {
          return 1;
        }
        if (weightA < weightB) {
          return -1;
        }
        return 0;
      });
      for (i = 0, len = sortedNodes.length; i < len; i++) {
        nodeData = sortedNodes[i];
        node = new supportedNodeTypes[nodeData.type](nodeData, true);
        node.build().addListeners().render();
      }
      // Display the reset and show-all buttons.
      document.getElementById("reset-button").style.display = "inline-block";
      document.getElementById("reset-button").classList.add("fade-in");
      // Show the hint after 5 seconds.
      return setTimeout((() => {
        var hint;
        hint = document.querySelector("#hint");
        hint.classList.add("fade-in");
        return setTimeout((() => {
          hint.classList.remove("fade-in");
          hint.classList.add("fade-out");
          return hint.addEventListener("animationend", () => {
            return hint.parentElement.removeChild(hint);
          });
        }), 7000);
      }), 1000);
    }

    // Displays the privacy popup.
    showPrivacyPopup() {
      var removePopup;
      removePopup = () => {
        var animationEnd;
        animationEnd = () => {
          this.privacyPopup.style.display = "none";
          return this.privacyPopup.removeEventListener("animationend", animationEnd);
        };
        this.privacyPopup.addEventListener("animationend", animationEnd);
        this.privacyPopup.classList.remove("fade-in");
        this.privacyPopup.classList.add("fade-out");
        this.privacyPopup.querySelector("#accept-button").removeEventListener("click", removePopup);
        return this.removeOverlay();
      };
      this.showOverlay(removePopup);
      this.privacyPopup.style.display = "block";
      this.privacyPopup.classList.remove("fade-out");
      this.privacyPopup.classList.add("fade-in");
      return this.privacyPopup.querySelector("#accept-button").addEventListener("click", removePopup);
    }

    // Animates the mindmap moving to its center.
    moveToCenter() {
      var content, contentH, contentW, rootH, rootW, rootX, rootY, targetX, targetY;
      this.isMovingToCenter = true;
      content = document.querySelector("#content");
      contentW = content.getBoundingClientRect().width;
      contentH = content.getBoundingClientRect().height;
      rootW = this.rootNode.getBoundingClientRect().width;
      rootH = this.rootNode.getBoundingClientRect().height;
      targetX = Math.ceil(contentW - rootW) / 2;
      targetY = Math.ceil(contentH - rootH) / 2;
      rootX = Math.ceil(this.rootNode.getBoundingClientRect().left);
      rootY = Math.ceil(this.rootNode.getBoundingClientRect().top);
      return this.animation.move(rootX, rootY, targetX, targetY, 500, () => {
        return this.isMovingToCenter = false;
      });
    }

    // Resets the state of the mindmap.
    // Keeps the selected study and year.
    reset() {
      var checkbox, expandButton, i, j, k, len, len1, len2, node, progressBar, ref, ref1, ref2, resetMessage;
      if (this.container.querySelectorAll(".node-expand.active").length === 0) {
        this.moveToCenter();
      }
      ref = this.container.querySelectorAll(".root-child");
      // Unchecks all checkboxes, resets the progressbars and collapses
      // the checklist nodes and their subtrees.
      for (i = 0, len = ref.length; i < len; i++) {
        node = ref[i];
        ref1 = node.querySelectorAll("input[type='checkbox']");
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          checkbox = ref1[j];
          checkbox.checked = false;
        }
        ref2 = node.querySelectorAll(".bar");
        for (k = 0, len2 = ref2.length; k < len2; k++) {
          progressBar = ref2[k];
          progressBar.style.width = "0px";
        }
        if (node.querySelector(".node").classList.contains("active")) {
          node.querySelector(".node-content-header").click();
        }
        expandButton = node.querySelector(".node-expand");
        if (expandButton && expandButton.classList.contains("active")) {
          expandButton.click();
        }
      }
      // Updates the textbubble.
      if (this.data.studies[this.selectedStudy].data.resetMessage && this.data.studies[this.selectedStudy].data.resetMessage.length) {
        resetMessage = document.createElement("span");
        resetMessage.classList.add("textBubbleContent", "standard");
        resetMessage.innerHTML = this.data.studies[this.selectedStudy].data.resetMessage;
        return this.updateTextBubbleContent(resetMessage);
      }
    }

    // Displays a semi-transparent, dark overlay over the screen
    // to emphasize a popup.
    showOverlay(callback = false) {
      var overlay;
      overlay = document.createElement("div");
      overlay.id = "overlay";
      overlay.classList.add("fade-in");
      overlay.addEventListener("click", () => {
        if (callback) {
          callback();
        }
        return this.removeOverlay();
      });
      return this.content.appendChild(overlay);
    }

    // Removes the overlay from the screen.
    removeOverlay() {
      var overlay;
      overlay = this.content.querySelector("#overlay");
      overlay.classList.remove("fade-in");
      overlay.classList.add("fade-out");
      return overlay.addEventListener("animationend", () => {
        if (this.content.contains(overlay)) {
          return this.content.removeChild(overlay);
        }
      });
    }

    // Zooms out the mindmap by 0.25 at a time.
    // Has a minimum zoomfactor of 0.25.
    zoomOut() {
      this.zoomFactor = Math.max(this.zoomFactor - 0.25, 0.25);
      return this.animation.scale(this.zoomFactor);
    }

    // Zooms in the mindmap by 0.25 at a time.
    // Has a maximum zoomfactor of 2.0.
    zoomIn() {
      this.zoomFactor = Math.min(this.zoomFactor + 0.25, 2.0);
      return this.animation.scale(this.zoomFactor);
    }

  };

  // Provides a simple interface to enable the dragging
  // and panning of the mindmap content.
  PanHandler = class PanHandler {
    // Initializes the variables used to keep track
    // of the movement.
    constructor() {
      // Uses the new position of the mouse to move the content.
      this.drag = this.drag.bind(this);
      this.listening = false;
      this.dragging = false;
      this.previousMouseX = this.previousMouseY = 0;
      this.content = document.getElementById("content");
      this.mindmap = document.getElementById("mindmap");
    }

    // Starts listening for pan events.
    startListening() {
      this.listening = true;
      this.bindMouseDown();
      this.bindMouseUp();
      this.bindTouchDown();
      this.bindTouchUp();
      this.bindMouseMove();
      return this.bindTouchMove();
    }

    // Binds the mousedown handler so we know when
    // the dragging starts.
    bindMouseDown() {
      return this.content.addEventListener("mousedown", (event) => {
        var overlay;
        overlay = document.getElementById("overlay");
        if (this.listening && !recursiveHasClass(event.target, "no-drag") && event.target !== overlay && !isDescendant(event.target, overlay)) {
          event.preventDefault();
          this.dragging = true;
          this.previousMouseX = event.clientX;
          this.previousMouseY = event.clientY;
          return document.body.style.cursor = "move";
        }
      });
    }

    // Binds the mouseup handler so we know when
    // the dragging ends.
    bindMouseUp() {
      return this.content.addEventListener("mouseup", (event) => {
        this.dragging = false;
        event.preventDefault();
        return document.body.style.cursor = "default";
      });
    }

    // Binds the touchdown handler so we know when
    // the dragging starts.
    bindTouchDown() {
      return this.content.addEventListener("touchstart", (event) => {
        if (this.listening && !recursiveHasClass(event.target, "no-drag")) {
          event.preventDefault();
          this.dragging = true;
          this.previousMouseX = event.targetTouches[0].pageX;
          return this.previousMouseY = event.targetTouches[0].pageY;
        }
      });
    }

    // Binds the touchup handler so we know when
    // the dragging ends.
    bindTouchUp() {
      return this.content.addEventListener("touchup", (event) => {
        this.dragging = false;
        return event.preventDefault();
      });
    }

    // Binds the mousemove handler so we can detect
    // dragging motions.
    bindMouseMove() {
      return this.content.addEventListener("mousemove", (event) => {
        if (this.dragging && this.listening) {
          event.preventDefault();
          this.drag(event.clientX, event.clientY);
          this.previousMouseX = event.clientX;
          return this.previousMouseY = event.clientY;
        }
      });
    }

    // Binds the touchmove handler so we can detect
    // dragging motions.
    bindTouchMove() {
      return this.content.addEventListener("touchmove", (event) => {
        if (this.dragging && this.listening) {
          event.preventDefault();
          this.drag(event.targetTouches[0].pageX, event.targetTouches[0].pageY);
          this.previousMouseX = event.targetTouches[0].pageX;
          return this.previousMouseY = event.targetTouches[0].pageY;
        }
      });
    }

    drag(currentMouseX, currentMouseY) {
      var movementX, movementY;
      movementX = currentMouseX - this.previousMouseX;
      movementY = currentMouseY - this.previousMouseY;
      return fg.mindmap.animation.moveSingleFrame(movementX, movementY);
    }

  };

  // Used to give unique IDs to all nodes.
  nodeCounter = 0;

  BaseNode = (function() {
    // Implements the basic methods and interface for every type of node.
    // Provides dynamic node construction, eventlisteners and the basic
    // behaviour of every node.
    class BaseNode {
      // Sets the basic properties of the node.
      constructor(nodeData1, isRootNode1 = false) {
        // The click-listener which filters out events for child-nodes
        // and passes the event to the @onClickEvent and optional
        // external event listeners.
        this.clickListener = this.clickListener.bind(this);
        this.nodeData = nodeData1;
        this.isRootNode = isRootNode1;
      }

      /* PUBLIC METHODS */
      // Builds the basic DOM node-object on which all types of nodes
      // are based.
      build() {
        this.createDOMElement();
        this.expanded = false;
        return this;
      }

      // Renders the created node by appending it to the DOM.
      render() {
        if (this.isRootNode) {
          this.targetParent = document.getElementById(`${this.nodeData.side}branch`);
        } else {
          this.targetParent = this.nodeData.parent.querySelector(".children.nested");
        }
        this.targetParent.appendChild(this.html);
        this.nodeData.element = this.html;
        this.setNodeSize();
        return this;
      }

      // Renders the node with an slide-in animation.
      renderAnimated() {
        this.html.classList.add("animate-in");
        this.render();
        return this;
      }

      // Re-renders the node in its current location.
      rerender() {
        var node, pageNode, swapContents, transitionEnd, wasOpened;
        pageNode = this.targetParent.querySelector(`#${this.html.id}`);
        node = pageNode.querySelector(".node");
        wasOpened = false;
        swapContents = () => {
          // Transfer classes and contents.
          if (pageNode.querySelector(".node-expand")) {
            this.html.querySelector(".node-expand").className = pageNode.querySelector(".node-expand").className;
          }
          this.html.removeChild(this.html.querySelector(".children.nested"));
          this.html.appendChild(pageNode.querySelector(".children.nested"));
          pageNode.className = this.html.className;
          this.html.querySelector(".node").className = pageNode.querySelector(".node").className;
          pageNode.innerHTML = "";
          pageNode.appendChild(this.html.querySelector(".node"));
          pageNode.appendChild(this.html.querySelector(".children.nested"));
          this.html = pageNode;
          this.setNodeSize();
          if (wasOpened) {
            return this.activateNode(this.html.querySelector(".node"));
          }
        };
        if (node.classList.contains("active")) {
          wasOpened = true;
          transitionEnd = function() {
            node.removeEventListener("transitionend", transitionEnd);
            return swapContents();
          };
          node.addEventListener("transitionend", transitionEnd);
          this.deactivateNode(node);
        } else {
          swapContents();
        }
        return this;
      }

      // Binds all required listeners for this node.
      // The listeners pass on the events to the right event-handler method.
      addListeners() {
        this.html.removeEventListener("click", this.clickListener);
        this.html.addEventListener("click", this.clickListener);
        this.bindHoverListeners();
        if (this.nodeData.children && this.nodeData.children.length) {
          this.bindExpansionHandler();
        }
        return this;
      }

      // Places focus on this node by moving it to the center.
      focus() {
        var expandButton, focusX, focusY, moveX, moveY;
        expandButton = this.html.querySelector(".node-expand");
        focusX = Math.ceil(document.getElementById("content").offsetWidth / 2 - expandButton.offsetWidth / 2);
        focusY = Math.ceil(document.getElementById("content").offsetHeight / 2 - expandButton.offsetHeight / 2);
        moveX = focusX - expandButton.getBoundingClientRect().left;
        moveY = focusY - expandButton.getBoundingClientRect().top;
        fg.mindmap.animation.moveRelative(moveX, moveY, 500);
        return this;
      }

      // Removes focus from this node by focussing on its parent-node.
      blur() {
        var expandButton, focusAnimation, focusX, focusY, moveX, moveY;
        if (this.isRootNode && !fg.mindmap.isMovingToCenter) {
          fg.mindmap.moveToCenter();
        } else if (this.nodeData.parent) {
          focusAnimation = new Animation(document.querySelector("#mindmap"));
          expandButton = this.nodeData.parent.querySelector(".node-expand");
          focusX = Math.ceil(document.getElementById("content").offsetWidth / 2 - expandButton.offsetWidth / 2);
          focusY = Math.ceil(document.getElementById("content").offsetHeight / 2 - expandButton.offsetHeight / 2);
          moveX = focusX - expandButton.getBoundingClientRect().left;
          moveY = focusY - expandButton.getBoundingClientRect().top;
          fg.mindmap.animation.moveRelative(moveX, moveY, 500);
        }
        return this;
      }

      // Adds the expand-button if the node didn't have one yet.
      addExpandButton() {
        this.html.querySelector(".node-content").appendChild(this.buildExpandButton());
        return this.bindExpansionHandler();
      }

      /* PRIVATE METHODS */
      // Opens the node to show its full contents.
      activateNode(node) {
        var activeContentHeight, contentHeight, contentWidth, message, moveX, moveY, nodeRect, target, targetX, targetY;
        node.classList.add("active");
        target = node.querySelector(".node-content");
        // Focus the screen on the opening node if the node is too
        // far off center.
        contentWidth = document.getElementById("content").offsetWidth;
        contentHeight = document.getElementById("content").offsetHeight;
        nodeRect = target.getBoundingClientRect();
        if ((nodeRect.x + nodeRect.width) > 0.75 * contentWidth || (nodeRect.y + nodeRect.height) > 0.75 * contentHeight || (nodeRect.x < 0.25 * contentWidth) || (nodeRect.y < 0.25 * contentHeight)) {
          targetX = contentWidth / 2 - nodeRect.width / 2;
          targetY = contentHeight / 2 - nodeRect.height / 2;
          moveX = targetX - nodeRect.left;
          moveY = targetY - nodeRect.top;
          fg.mindmap.animation.moveRelative(moveX, moveY, 500);
        }
        // Open the new node.
        this.originalHeight = this.originalHeight || getOuterHeight(target);
        activeContentHeight = getOuterHeight(target.getElementsByClassName("node-active-content")[0]);
        node.style.height = `${this.originalHeight + activeContentHeight}px`;
        // If set, show the open-message.
        if (getText(this.nodeData.messages.open) && getText(this.nodeData.messages.open).length > 0) {
          message = document.createElement("span");
          message.className = "textBubbleContent standard";
          message.innerHTML = this.nodeData.messages.open;
          return fg.mindmap.updateTextBubbleContent(message);
        }
      }

      // Closes the node to go back to its original height.
      deactivateNode(node) {
        var message;
        node.classList.remove("active");
        node.style.height = `${this.originalHeight}px`;
        // If set, show the close-message.
        if (getText(this.nodeData.messages.close) && getText(this.nodeData.messages.close).length > 0) {
          message = document.createElement("span");
          message.className = "textBubbleContent standard";
          message.innerHTML = this.nodeData.messages.close;
          return fg.mindmap.updateTextBubbleContent(message);
        }
      }

      // Expands or minimizes the node on a user-click.
      // Can be extended by inheriting classes to handle click-events
      // with other purposes.
      onClickEvent(event) {
        var node, target;
        // Skip actions on elements that have non-default actions, such as checkboxes.
        if (recursiveHasClass(event.target, "prevent-default")) {
          return;
        }
        // Skip actions on elements that by default have their own actions,
        // such as links and buttons.
        if (["A", "BUTTON"].includes(event.target.tagName)) {
          return;
        }
        target = event.target.closest(".node-content");
        // Skip if the node itself wasn't clicked.
        if (target === null) {
          return;
        }
        node = target.closest(".node");
        // Toggle the size of the node.
        if (node.classList.contains("active")) {
          this.deactivateNode(node);
        } else {
          this.activateNode(node);
        }
      }

      // Creates the basic DOM element on which every node is based
      // and stores it in @html.
      createDOMElement() {
        var activeContent, arrow, chevron, childrenContainer, cleanedName, content, contentContainer, header, name, node, nodeContainer, nodeID, rule, target;
        if (typeof this.html !== "undefined") {
          nodeID = this.html.id;
        } else {
          nodeID = `node-${nodeCounter++}`;
        }
        // Create all HTML elements.
        nodeContainer = document.createElement("li");
        nodeContainer.id = nodeID;
        nodeContainer.classList.add("child-item");
        if (this.isRootNode) {
          nodeContainer.classList.add("root-child");
        }
        node = document.createElement("div");
        node.classList.add("node", "no-drag");
        node.style.backgroundColor = this.nodeData.color;
        contentContainer = document.createElement("div");
        contentContainer.classList.add("node-content-container");
        header = document.createElement("div");
        header.classList.add("node-content-header");
        content = document.createElement("div");
        content.classList.add("node-content");
        name = document.createElement("div");
        name.classList.add("node-name");
        name.innerHTML = this.nodeData.name;
        cleanedName = document.createElement("div");
        cleanedName.innerHTML = this.nodeData.name;
        name.style.width = `${measureTextWidth(cleanedName.innerText)}px`;
        activeContent = document.createElement("div");
        activeContent.classList.add("node-active-content");
        childrenContainer = document.createElement("ol");
        childrenContainer.classList.add("children", "nested");
        // Add the expand-arrow for child-nodes.
        if (this.nodeData.children && this.nodeData.children.length) {
          content.appendChild(this.buildExpandButton());
        }
        // Style the colored lines that run to the node.
        target = `#${nodeID}.child-item,#leftbranch #${nodeID}.child-item:before,#rightbranch #${nodeID}.child-item:before`;
        rule = `border-color: ${this.nodeData.color}`;
        document.styleSheets[0].addRule(target, rule);
        // Add the open/close arrow.
        arrow = document.createElement("div");
        arrow.classList.add("node-arrow");
        chevron = document.createElement("i");
        chevron.classList.add("fa", "fa-chevron-right");
        arrow.appendChild(chevron);
        // Put all the HTML elements together.
        header.appendChild(name);
        header.appendChild(arrow);
        contentContainer.appendChild(header);
        contentContainer.appendChild(activeContent);
        content.appendChild(contentContainer);
        node.appendChild(content);
        nodeContainer.appendChild(node);
        nodeContainer.appendChild(childrenContainer);
        this.html = nodeContainer;
      }

      clickListener(event) {
        var blockedByExternalListener, childContainer, externalListener, i, len, ref;
        childContainer = this.html.querySelector(".children.nested");
        // Filter out any events on children of this node.
        if (!isDescendant(event.target, childContainer)) {
          blockedByExternalListener = false;
          // Notify all external clicklisteners, such as the editor.
          if (this.externalClickListeners) {
            ref = this.externalClickListeners;
            for (i = 0, len = ref.length; i < len; i++) {
              externalListener = ref[i];
              blockedByExternalListener |= externalListener(this, event);
            }
          }
          // And then notify the internal listener.
          if (!blockedByExternalListener) {
            return this.onClickEvent(event);
          }
        }
      }

      // Binds the hover-listeners used for visual indications
      // such as the striped border.
      bindHoverListeners() {
        var container, expandButton, node;
        node = this.html.querySelector(".node");
        container = this.html.querySelector(".node-content-container");
        expandButton = this.html.querySelector(".node-expand");
        // The hover-effect on the node itself.
        container.addEventListener("mouseover", () => {
          return node.classList.add("hover");
        });
        container.addEventListener("mouseout", () => {
          return node.classList.remove("hover");
        });
        // The hover-effect on the expand-button.
        if (expandButton) {
          expandButton.addEventListener("mouseover", () => {
            return expandButton.classList.add("hover");
          });
          return expandButton.addEventListener("mouseout", () => {
            return expandButton.classList.remove("hover");
          });
        }
      }

      // Binds the expansionhandler that allows the user to expand
      // a sub-branch of this node and see it's child-nodes.
      bindExpansionHandler() {
        var expandButton;
        expandButton = this.html.querySelector(".node-expand");
        return expandButton.addEventListener("click", (event) => {
          // Toggle the child-container.
          expandButton.classList.toggle("active");
          this.expanded = !this.expanded;
          if (this.expanded) {
            this.expandChildren();
          } else {
            this.collapseChildren();
          }
        });
      }

      // Expands the child-nodes of the node.
      expandChildren() {
        var child, childNode, i, len, sortedChildren;
        sortedChildren = this.nodeData.children.sort(function(a, b) {
          if (a.weight > b.weight) {
            return 1;
          }
          if (a.weight < b.weight) {
            return -1;
          }
          return 0;
        });
        for (i = 0, len = sortedChildren.length; i < len; i++) {
          child = sortedChildren[i];
          // Extend the child-node with data from the parent-node.
          child.parent = this.html;
          child.parentObject = this;
          child.side = this.nodeData.side;
          childNode = new supportedNodeTypes[child.type](child);
          childNode.build().addListeners().renderAnimated();
        }
        // Place focus on the node.
        return this.focus();
      }

      // Collapse the child-nodes of the node.
      collapseChildren() {
        var child, childContainer, children, i, index, len;
        childContainer = this.html.querySelector(".children.nested");
        children = childContainer.querySelectorAll(".child-item");
        for (index = i = 0, len = children.length; i < len; index = ++i) {
          child = children[index];
          child.classList.add("animate-out");
          if (index === children.length - 1) {
            child.addEventListener("animationend", function() {
              return childContainer.innerHTML = "";
            });
          }
        }
        // Place focus on the node's parent.
        return this.blur();
      }

      // Sets the node-width correctly in absolute number of pixels so that the hover-border
      // has the correct size.
      // Not the most beautiful solution, but this can't be calculated in the build-function
      // since the browser doesn't know the real size of an element until its rendered.
      setNodeSize() {
        return this.html.querySelector(".node").style.width = `${(this.html.querySelector(".node-content-container").offsetWidth)}px`;
      }

      // Simply builds and returns the HTML element for the expand-button
      // so it can be appended to the node.
      buildExpandButton() {
        var chevron, nodeExpand, pipe;
        // Create the HTML elements.
        nodeExpand = document.createElement("div");
        nodeExpand.classList.add("node-expand", "prevent-default");
        nodeExpand.style.backgroundColor = this.nodeData.color;
        chevron = document.createElement("div");
        chevron.classList.add("chevron", this.nodeData.side);
        pipe = document.createElement("div");
        pipe.classList.add("pipe");
        // And combine them.
        nodeExpand.appendChild(chevron);
        nodeExpand.appendChild(pipe);
        return nodeExpand;
      }

    };

    // Keeps track of external clicklisteners that can subscribe
    // to click-events on this node, such as the editor.
    BaseNode.externalClickListeners = [];

    return BaseNode;

  }).call(this);

  // A simple checklist with progressbar to reflect on
  // the number of checkboxes checked.
  ChecklistNode = class ChecklistNode extends BaseNode {
    // Extends the basic node-HTML with checklist-specific extra's.
    build() {
      var bar, checkbox, checklist, checklistID, checkmark, i, item, label, len, progressbar, ref, rule, target, theorem;
      // Create the base node-html.
      super.build();
      // And extend it to a checklist node.
      this.html.classList.add("checklist");
      // Add the progressbar.
      progressbar = document.createElement("div");
      progressbar.classList.add("node-checklist-progressbar");
      bar = document.createElement("div");
      bar.classList.add("bar");
      progressbar.appendChild(bar);
      this.html.querySelector(".node-content-container").appendChild(progressbar);
      // Add the actual checklist.
      checklist = document.createElement("ul");
      checklistID = this.html.id;
      target = `#${checklistID} .checkmark:after`;
      rule = `border-style:solid!important;border-color:${this.nodeData.color}!important;border-image:initial!important;border-width: 0 3px 3px 0 !important;`;
      if (navigator.userAgent.toLowerCase().indexOf('firefox') > -1) {
        document.styleSheets[0].insertRule(`${target} {${rule}}`);
      } else {
        document.styleSheets[0].addRule(target, rule);
      }
      ref = this.nodeData.data.theorems;
      for (i = 0, len = ref.length; i < len; i++) {
        theorem = ref[i];
        item = document.createElement("li");
        item.classList.add("checkbox-item", "prevent-default");
        label = document.createElement("label");
        label.classList.add("container");
        label.innerHTML = theorem;
        checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkmark = document.createElement("div");
        checkmark.classList.add("checkmark", checklistID);
        label.appendChild(checkbox);
        label.appendChild(checkmark);
        item.appendChild(label);
        checklist.appendChild(item);
      }
      this.html.querySelector(".node-active-content").appendChild(checklist);
      return this;
    }

    // Adds eventlisteners for the checkboxes that update the progressbar
    // when the user checks one or more checkboxes.
    onClickEvent(event) {
      var allCheckboxes, bar, checkedCheckboxes, expandButton, feedback, i, len, parent, percentage, percentageChecked, ref, results, target;
      // Process normal click-events first.
      super.onClickEvent(event);
      // Skip the event if this is no checkbox.
      if (!recursiveHasClass(event.target, "checkbox-item")) {
        return;
      }
      target = event.target;
      parent = target.closest(".node");
      bar = parent.querySelector(".bar");
      // Calculate the percentage of checked checkboxes.
      checkedCheckboxes = parent.querySelectorAll("input[type='checkbox']:checked").length;
      allCheckboxes = parent.querySelectorAll("input[type='checkbox']").length;
      percentageChecked = Math.ceil(checkedCheckboxes / allCheckboxes * 100);
      // And update the progressbar.
      bar.style.width = `${percentageChecked}%`;
      // Assure the subtree is expanded if two or more
      // checkboxes are checked.
      if (checkedCheckboxes >= 2) {
        expandButton = parent.querySelector(".node-expand");
        if (expandButton && !(expandButton.classList.contains("active"))) {
          expandButton.click();
        }
      }
      ref = Object.keys(this.nodeData.data.feedback).reverse();
      // Place optional feedback in the textbubble.
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        percentage = ref[i];
        if (percentageChecked >= percentage) {
          feedback = document.createElement("span");
          feedback.classList.add("textBubbleContent", "standard");
          feedback.innerHTML = this.nodeData.data.feedback[percentage];
          fg.mindmap.updateTextBubbleContent(feedback);
          break;
        } else {
          results.push(void 0);
        }
      }
      return results;
    }

  };

  TextNode = class TextNode extends BaseNode {
    // Extends the basic node-HTML with textnode-specific extra's.
    build() {
      // Create the base node-html.
      super.build();
      this.html.classList.add("text");
      this.html.querySelector(".node-active-content").innerHTML = this.nodeData.data.text;
      return this;
    }

  };

  VideoNode = class VideoNode extends BaseNode {
    // Extends the basic node-HTML with videonode-specific extra's.
    build() {
      var text, video;
      // Create the base node-html.
      super.build();
      this.html.classList.add("video");
      // If set, add text to be displayed above the video.
      if (this.nodeData.data.text) {
        text = document.createElement("div");
        text.classList.add("text");
        text.innerHTML = this.nodeData.data.text;
        this.html.querySelector(".node-active-content").appendChild(text);
      }
      if (this.nodeData.data.url) {
        this.open = false;
        video = document.createElement("iframe");
        video.frameborder = 0;
        video.setAttribute("allowfullscreen", "");
        video.setAttribute("mozallowfullscreen", "");
        video.setAttribute("msallowfullscreen", "");
        video.setAttribute("oallowfullscreen", "");
        video.setAttribute("webkitallowfullscreen", "");
        video.classList.add("frame");
        this.html.querySelector(".node-active-content").appendChild(video);
      }
      return this;
    }

    activateNode() {
      super.activateNode(this.html.querySelector(".node"));
      if (!this.open) {
        this.html.querySelector("iframe").src = this.nodeData.data.url;
        return this.open = true;
      }
    }

  };

  // Supported node-types.
  supportedNodeTypes = {
    "checklist": ChecklistNode,
    "text": TextNode,
    "video": VideoNode
  };

  // Lists all node-properties that can be edited.
  EDITABLE_PROPERTIES = ["name", "color", "messages_open", "messages_close", "weight", "data_theorems", "data_feedback", "data_text", "data_url", "type"];

  // Maps all internal property-names
  // to normal names.
  NORMALIZED_NAMES = {
    "name": "Naam",
    "color": "Kleur",
    "messages_open": "Openingstekst",
    "messages_close": "Sluitingstekst",
    "weight": "Positie",
    "data_theorems": "Stellingen",
    "data_feedback": "Feedback",
    "data_text": "Tekst",
    "data_url": "Video link",
    "type": "Node Type"
  };

  // Mapping of editable properties from their
  // internal name to their input-type.
  PROPERTY_TYPES = {
    "name": "text",
    "color": "color",
    "messages_open": "multilinetext",
    "messages_close": "multilinetext",
    "weight": "position",
    "data_theorems": "multitext",
    "data_feedback": "feedback",
    "data_text": "multilinetext",
    "data_url": "videourl",
    "type": "nodetype" // Provides a simple link between nodes and
  };

  Editor = (function() {
    var studiesEditorOpen, wysiwygEditorOpen;

    // the editor sidemenu.
    class Editor {
      constructor() {
        // Hooks onto the nodes' click-event and links
        // all alt-clicks from the standard eventlisteners to the
        // editor-listeners.
        this.editorLink = this.editorLink.bind(this);
      }

      editorLink(node, event) {
        var previousNode;
        if (event.altKey) {
          // Highlight the clicked node.
          previousNode = document.querySelector(".editor-selected");
          if (previousNode) {
            previousNode.classList.remove("editor-selected");
          }
          node.html.querySelector(".node").classList.add("editor-selected");
          this.node = node;
          this.editorContent = document.getElementById("editor-sidemenu-content");
          // Open the node in the editor and, if it was closed, open the editor.
          this.openInEditor();
          if (window.fg.sidemenu.closed) {
            window.fg.sidemenu.slideIn();
          }
          event.stopPropagation();
          return true;
        } else {
          return false;
        }
      }

      // Opens the selected node in the editor so its
      // properties can be edited.
      openInEditor() {
        var prop, property, ref, ref1, val, value;
        // First remove all old content from the editor.
        this.editorContent.innerHTML = "";
        ref = this.node.nodeData;
        // Add all editable items to the sidemenu.
        for (property in ref) {
          value = ref[property];
          // Unpack nested properties.
          if (typeof value === "object") {
            for (prop in value) {
              val = value[prop];
              if (ref1 = `${property}_${prop}`, indexOf.call(EDITABLE_PROPERTIES, ref1) >= 0) {
                this.createItem(`${property}_${prop}`, val).addToEditor();
              }
            }
          } else {
            if (indexOf.call(EDITABLE_PROPERTIES, property) >= 0) {
              this.createItem(property, value).addToEditor();
            }
          }
        }
        // Default add/remove buttons for every node.
        this.addRemoveButtonCreate().addToEditor();
        // Start listening for changes in the editor to automatically
        // update the node.
        this.listenForChanges();
        return this;
      }

      // Adds the button to the study-select balloon to launch that
      // enables the user to edit the studies.
      addEditStudiesButton() {
        var bubble, button;
        bubble = document.querySelector(".textBubbleContent.studySelect");
        button = document.createElement("button");
        button.id = "edit-studies-button";
        button.innerHTML = "Pas studies aan <i class='far fa-edit'></i>";
        button.addEventListener("click", this.studiesEditor);
        bubble.appendChild(button);
        return this;
      }

      studiesEditor() {
        var addStudyButton, closeButton, detailsColumn, i, item, len, name, openStudyListener, ref, removeEditor, studiesColumn, studiesEditorContainer, study, years;
        if (studiesEditorOpen) {
          return;
        }
        studiesEditorOpen = true;
        // Create the popup-container to hold everything.
        studiesEditorContainer = document.createElement("div");
        studiesEditorContainer.id = "studies-editor-container";
        studiesEditorContainer.className = "no-drag";
        openStudyListener = (e) => {
          var actionsTitle, addYearButton, buttonContainer, copyButton, createYearItem, deleteButton, detailsContainer, divider, i, info, item, j, len, len1, messageDivider, messagesTitle, moveDownButton, moveUpButton, ref, renameButton, resetEdit, resetTitle, sortedStudyYears, study, studyData, studyItem, studyYears, title, welcomeEdit, welcomeTitle, year, yearsContainer, yearsDivider, yearsTitle;
          if (e.target.closest(".study-row").classList.contains("active")) {
            return;
          }
          ref = document.querySelectorAll(".study-row");
          for (i = 0, len = ref.length; i < len; i++) {
            item = ref[i];
            item.classList.remove("active");
          }
          studyItem = e.target.closest(".study-row");
          studyItem.classList.add("active");
          study = studyItem.getAttribute("data-study");
          studyData = window.fg.mindmap.data.studies[study];
          detailsContainer = document.querySelector("#details-column");
          detailsContainer.innerHTML = "";
          // Study itself.
          title = document.createElement("h2");
          title.id = "study-title";
          title.innerText = study;
          detailsContainer.appendChild(title);
          info = document.createElement("h6");
          info.className = "study-info";
          info.innerText = `${(Object.keys(studyData.years).length)} studiejaren`;
          detailsContainer.appendChild(info);
          divider = document.createElement("hr");
          detailsContainer.appendChild(divider);
          actionsTitle = document.createElement("h3");
          actionsTitle.innerText = "Acties";
          detailsContainer.appendChild(actionsTitle);
          buttonContainer = document.createElement("div");
          buttonContainer.id = "buttonContainer";
          copyButton = document.createElement("button");
          copyButton.id = "copy-study-button";
          copyButton.innerHTML = "Studie dupliceren <i class='far fa-copy'></i>";
          copyButton.addEventListener("click", () => {
            var copiedName, name, option, years;
            copiedName = window.prompt("Wat is de naam van de nieuwe studie?");
            window.fg.mindmap.data.studies[copiedName] = JSON.parse(JSON.stringify(window.fg.mindmap.data.studies[study]));
            window.fg.mindmap.data.studies[copiedName].data.weight = Object.keys(window.fg.mindmap.data.studies).length;
            option = document.createElement("option");
            option.value = window.fg.mindmap.data.studies[copiedName].data.weight - 1;
            option.innerText = copiedName;
            document.querySelector("#studySelect").appendChild(option);
            window.fg.mindmap.sortedStudies.push(copiedName);
            item = document.createElement("div");
            item.classList.add("study-row");
            item.setAttribute("data-study", copiedName);
            name = document.createElement("span");
            name.className = "study-name";
            name.innerHTML = copiedName;
            item.appendChild(name);
            years = document.createElement("span");
            years.className = "study-year-count";
            years.innerHTML = `${(Object.keys(window.fg.mindmap.data.studies[copiedName].years).length)} studiejaren`;
            item.appendChild(years);
            item.addEventListener("click", (e) => {
              return openStudyListener(e);
            });
            return studiesColumn.insertBefore(item, document.querySelector("#add-study-button"));
          });
          buttonContainer.appendChild(copyButton);
          deleteButton = document.createElement("button");
          deleteButton.id = "delete-study-button";
          deleteButton.innerHTML = "Studie verwijderen <i class='far fa-trash-alt'></i>";
          deleteButton.addEventListener("click", () => {
            var j, len1, option, ref1;
            if (window.confirm(`Weet je zeker dat je de studie '${study}' wil verwijderen?`)) {
              delete window.fg.mindmap.data.studies[study];
              studyItem.parentElement.removeChild(studyItem);
              window.fg.mindmap.sortedStudies.splice(window.fg.mindmap.sortedStudies.indexOf(study), 1);
              ref1 = document.querySelectorAll("#studySelect option");
              for (j = 0, len1 = ref1.length; j < len1; j++) {
                option = ref1[j];
                if (option.innerText === study) {
                  option.parentElement.removeChild(option);
                  return;
                }
              }
              return document.querySelector("#details-column").innerHTML = `<h3>'${study}' is verwijderd</h3>`;
            }
          });
          buttonContainer.appendChild(deleteButton);
          renameButton = document.createElement("button");
          renameButton.id = "rename-study-button";
          renameButton.innerHTML = "Studie hernoemen <i class='far fa-edit'></i>";
          renameButton.addEventListener("click", () => {
            var newName, row;
            newName = window.prompt("Wat is de nieuwe naam van de studie?");
            if (newName) {
              window.fg.mindmap.data.studies[newName] = JSON.parse(JSON.stringify(window.fg.mindmap.data.studies[study]));
              delete window.fg.mindmap.data.studies[study];
              document.querySelector("#study-title").innerText = newName;
              row = document.querySelector(`#studies-column .study-row[data-study='${study}']`);
              row.setAttribute("data-study", newName);
              row.querySelector(".study-name").innerText = newName;
              document.querySelector(`#studySelect option[value='${window.fg.mindmap.sortedStudies.indexOf(study)}']`).innerText = newName;
              return window.fg.mindmap.sortedStudies[window.fg.mindmap.sortedStudies.indexOf(study)] = newName;
            }
          });
          buttonContainer.appendChild(renameButton);
          moveUpButton = document.createElement("button");
          moveUpButton.id = "move-up-button";
          moveUpButton.innerHTML = "Omhoog <i class='fas fa-sort-up'></i>";
          if (studyData.data.weight === 1) {
            moveUpButton.disabled = true;
          }
          moveUpButton.addEventListener("click", () => {
            var higherStudy, higherWeight, index, j, len1, name, o, ref1, results, studyRow;
            moveDownButton.disabled = false;
            higherStudy = Object.keys(window.fg.mindmap.data.studies).find(key => window.fg.mindmap.data.studies[key].data.weight == studyData.data.weight - 1);
            higherWeight = window.fg.mindmap.data.studies[higherStudy].data.weight;
            window.fg.mindmap.data.studies[higherStudy].data.weight = studyData.data.weight;
            studyData.data.weight = higherWeight;
            studyItem.parentNode.insertBefore(studyItem, studyItem.previousElementSibling);
            if (studyData.data.weight === 1) {
              moveUpButton.disabled = true;
            }
            window.fg.mindmap.sortedStudies = [];
            document.querySelector("#studySelect").innerHTML = "<option value='null' selected='' disabled='' class='placeholder'>Selecteer je studie</option>";
            ref1 = document.querySelectorAll("#studies-column .study-row");
            results = [];
            for (index = j = 0, len1 = ref1.length; j < len1; index = ++j) {
              studyRow = ref1[index];
              name = studyRow.getAttribute("data-study");
              window.fg.mindmap.sortedStudies.push(name);
              o = document.createElement("option");
              o.value = index;
              o.innerText = name;
              results.push(document.querySelector("#studySelect").appendChild(o));
            }
            return results;
          });
          buttonContainer.appendChild(moveUpButton);
          moveDownButton = document.createElement("button");
          moveDownButton.id = "move-down-button";
          moveDownButton.innerHTML = "Omlaag <i class='fas fa-sort-down'></i>";
          if (studyData.data.weight === Object.keys(window.fg.mindmap.data.studies).length) {
            moveDownButton.disabled = true;
          }
          moveDownButton.addEventListener("click", () => {
            var index, j, len1, lowerStudy, lowerWeight, name, o, ref1, results, studyRow;
            moveUpButton.disabled = false;
            lowerStudy = Object.keys(window.fg.mindmap.data.studies).find(key => window.fg.mindmap.data.studies[key].data.weight == studyData.data.weight + 1);
            lowerWeight = window.fg.mindmap.data.studies[lowerStudy].data.weight;
            window.fg.mindmap.data.studies[lowerStudy].data.weight = studyData.data.weight;
            studyData.data.weight = lowerWeight;
            studyItem.parentNode.insertBefore(studyItem.nextElementSibling, studyItem);
            if (studyData.data.weight === Object.keys(window.fg.mindmap.data.studies).length) {
              moveDownButton.disabled = true;
            }
            window.fg.mindmap.sortedStudies = [];
            document.querySelector("#studySelect").innerHTML = "<option value='null' selected='' disabled='' class='placeholder'>Selecteer je studie</option>";
            ref1 = document.querySelectorAll("#studies-column .study-row");
            results = [];
            for (index = j = 0, len1 = ref1.length; j < len1; index = ++j) {
              studyRow = ref1[index];
              name = studyRow.getAttribute("data-study");
              window.fg.mindmap.sortedStudies.push(name);
              o = document.createElement("option");
              o.value = index;
              o.innerText = name;
              results.push(document.querySelector("#studySelect").appendChild(o));
            }
            return results;
          });
          buttonContainer.appendChild(moveDownButton);
          detailsContainer.appendChild(buttonContainer);
          // Messages.
          messageDivider = document.createElement("hr");
          detailsContainer.appendChild(messageDivider);
          messagesTitle = document.createElement("h3");
          messagesTitle.innerText = "Berichten";
          detailsContainer.appendChild(messagesTitle);
          welcomeTitle = document.createElement("h6");
          welcomeTitle.className = "message-title";
          welcomeTitle.innerText = "Welkomst-tekst";
          detailsContainer.appendChild(welcomeTitle);
          welcomeEdit = document.createElement("div");
          welcomeEdit.className = "input message-edit";
          welcomeEdit.innerHTML = studyData.data.welcomeMessage || "Lorem ipsum dolor";
          welcomeEdit.addEventListener("click", () => {
            return window.fg.editor.createWYSIWYGEditor(welcomeEdit.innerHTML, true, function(value) {
              welcomeEdit.innerHTML = value;
              return window.fg.mindmap.data.studies[study].data.welcomeMessage = value;
            });
          });
          detailsContainer.appendChild(welcomeEdit);
          resetTitle = document.createElement("h6");
          resetTitle.className = "message-title";
          resetTitle.innerText = "Reset-tekst";
          detailsContainer.appendChild(resetTitle);
          resetEdit = document.createElement("div");
          resetEdit.className = "input message-edit";
          resetEdit.innerHTML = studyData.data.resetMessage || "Lorem ipsum dolor";
          resetEdit.addEventListener("click", () => {
            return window.fg.editor.createWYSIWYGEditor(resetEdit.innerHTML, true, function(value) {
              resetEdit.innerHTML = value;
              return window.fg.mindmap.data.studies[study].data.resetMessage = value;
            });
          });
          detailsContainer.appendChild(resetEdit);
          // Study years.
          yearsDivider = document.createElement("hr");
          detailsContainer.appendChild(yearsDivider);
          yearsTitle = document.createElement("h3");
          yearsTitle.innerText = "Studiejaren";
          detailsContainer.appendChild(yearsTitle);
          yearsContainer = document.createElement("ul");
          yearsContainer.id = "years-container";
          studyYears = Object.keys(studyData.years);
          sortedStudyYears = studyYears.sort(function(a, b) {
            var weightA, weightB;
            weightA = parseInt(studyData.years[a].data.weight);
            weightB = parseInt(studyData.years[b].data.weight);
            if (weightA > weightB) {
              return 1;
            }
            if (weightA < weightB) {
              return -1;
            }
            return 0;
          });
          createYearItem = (year) => {
            let yearName = year;
            let item = document.createElement("li");
            var changeNameButton, dupButton, name;
            name = document.createElement("label");
            name.innerText = yearName;
            item.appendChild(name);
            deleteButton = document.createElement("button");
            deleteButton.className = "delete";
            deleteButton.innerHTML = "<i class='far fa-trash-alt'></i>";
            deleteButton.addEventListener("click", () => {
              if (window.confirm(`Weet je zeker dat je het studiejaar '${yearName}' wilt verwijderen?`)) {
                yearsContainer.removeChild(item);
                return delete studyData.years[yearName];
              }
            });
            item.appendChild(deleteButton);
            dupButton = document.createElement("button");
            dupButton.className = "duplicate";
            dupButton.innerHTML = "<i class='far fa-copy'></i>";
            dupButton.addEventListener("click", () => {
              var dupName, studyCount;
              dupName = window.prompt("Wat is de naam van de nieuwe studie?");
              if (dupName) {
                window.fg.mindmap.data.studies[study].years[dupName] = JSON.parse(JSON.stringify(studyData.years[yearName]));
                window.fg.mindmap.data.studies[study].years[dupName].data.weight = Object.keys(studyData.years).length;
                if (document.querySelector("#years-container .order.down:disabled")) {
                  document.querySelector("#years-container .order.down:disabled").disabled = false;
                }
                studyCount = parseInt(document.querySelector(`#studies-column [data-study='${study}'] .study-year-count`).innerText) + 1;
                document.querySelector(`#studies-column [data-study='${study}'] .study-year-count`).innerText = `${studyCount} studiejaren`;
                document.querySelector("#details-column h6").innerText = `${studyCount} studiejaren`;
                return createYearItem(dupName);
              }
            });
            item.appendChild(dupButton);
            let downButton = document.createElement("button");
            downButton.className = "order down";
            downButton.innerHTML = "<i class='fas fa-sort-down'></i>";
            if (parseInt(studyData.years[yearName].data.weight) === Object.keys(studyData.years).length) {
              downButton.disabled = true;
            }
            item.appendChild(downButton);
            let upButton = document.createElement("button");
            upButton.className = "order up";
            upButton.innerHTML = "<i class='fas fa-sort-up'></i>";
            if (parseInt(studyData.years[yearName].data.weight) === 1) {
              upButton.disabled = true;
            }
            item.appendChild(upButton);
            downButton.addEventListener("click", () => {
              var lowerYear;
              lowerYear = Object.keys(studyData.years).find(key => studyData.years[key].data.weight == parseInt(studyData.years[yearName].data.weight) + 1);
              studyData.years[higherYear].data.weight = parseInt(studyData.years[higherYear].data.weight) - 1;
              item.nextElementSibling.querySelector(".order.down").disabled = downButton.disabled;
              item.nextElementSibling.querySelector(".order.up").disabled = upButton.disabled;
              upButton.disabled = false;
              yearsContainer.insertBefore(item.nextElementSibling, item);
              studyData.years[yearName].data.weight = parseInt(studyData.years[yearName].data.weight) + 1;
              if (parseInt(studyData.years[yearName].data.weight) === Object.keys(studyData.years).length) {
                return downButton.disabled = true;
              }
            });
            upButton.addEventListener("click", () => {
              var higherYear;
              higherYear = Object.keys(studyData.years).find(key => studyData.years[key].data.weight == parseInt(studyData.years[yearName].data.weight) - 1);
              studyData.years[higherYear].data.weight = parseInt(studyData.years[higherYear].data.weight) + 1;
              item.previousElementSibling.querySelector(".order.down").disabled = downButton.disabled;
              item.previousElementSibling.querySelector(".order.up").disabled = upButton.disabled;
              downButton.disabled = false;
              yearsContainer.insertBefore(item, item.previousElementSibling);
              studyData.years[yearName].data.weight = parseInt(studyData.years[yearName].data.weight) - 1;
              if (parseInt(studyData.years[yearName].data.weight) === 1) {
                return upButton.disabled = true;
              }
            });
            changeNameButton = document.createElement("button");
            changeNameButton.className = "edit";
            changeNameButton.innerHTML = "<i class='far fa-edit'></i>";
            changeNameButton.addEventListener("click", () => {
              var newName;
              newName = window.prompt(`Wat is de nieuwe naam van '${yearName}'?`);
              if (newName) {
                studyData.years[newName] = JSON.parse(JSON.stringify(studyData.years[yearName]));
                name.innerText = newName;
                return delete studyData.years[yearName];
              }
            });
            item.appendChild(changeNameButton);
            return yearsContainer.appendChild(item);
          };
          for (j = 0, len1 = sortedStudyYears.length; j < len1; j++) {
            year = sortedStudyYears[j];
            createYearItem(year);
          }
          detailsContainer.appendChild(yearsContainer);
          addYearButton = document.createElement("button");
          addYearButton.id = "add-year-button";
          addYearButton.innerHTML = "Jaar toevoegen <i class='fas fa-plus-square'></i>";
          addYearButton.addEventListener("click", () => {
            var studyCount, yearName;
            yearName = window.prompt("Wat is de naam van het nieuwe studiejaar?");
            if (yearName) {
              studyData.years[yearName] = {
                data: {
                  weight: Object.keys(studyData.years).length + 1
                },
                nodes: [
                  {
                    children: [],
                    name: "Nieuwe node....",
                    color: "#6b2565",
                    type: "text",
                    messages: {
                      open: "Lorem ipsum dolor sit amet",
                      close: "Lorem ipsum dolor sit amet"
                    },
                    data: {
                      text: "Lorem ipsum dolor sit amet"
                    },
                    side: "left",
                    weight: 1
                  }
                ]
              };
              createYearItem(yearName);
              studyCount = parseInt(document.querySelector(`#studies-column [data-study='${study}'] .study-year-count`).innerText) + 1;
              document.querySelector(`#studies-column [data-study='${study}'] .study-year-count`).innerText = `${studyCount} studiejaren`;
              return document.querySelector("#details-column h6").innerText = `${studyCount} studiejaren`;
            }
          });
          return detailsContainer.appendChild(addYearButton);
        };
        // Create the left column containing the studies.
        studiesColumn = document.createElement("div");
        studiesColumn.id = "studies-column";
        ref = window.fg.mindmap.sortedStudies;
        for (i = 0, len = ref.length; i < len; i++) {
          study = ref[i];
          item = document.createElement("div");
          item.classList.add("study-row");
          item.setAttribute("data-study", study);
          name = document.createElement("span");
          name.className = "study-name";
          name.innerHTML = study;
          item.appendChild(name);
          years = document.createElement("span");
          years.className = "study-year-count";
          years.innerHTML = `${(Object.keys(window.fg.mindmap.data.studies[study].years).length)} studiejaren`;
          item.appendChild(years);
          item.addEventListener("click", (e) => {
            return openStudyListener(e);
          });
          studiesColumn.appendChild(item);
        }
        studiesEditorContainer.appendChild(studiesColumn);
        // Create the button to add a study.
        addStudyButton = document.createElement("button");
        addStudyButton.id = "add-study-button";
        addStudyButton.innerHTML = "Studie toevoegen <i class='fas fa-plus-square'></i>";
        addStudyButton.addEventListener("click", () => {
          var newStudyName, newStudyWeight;
          newStudyName = window.prompt("Wat is de naam van de toe te voegen studie?");
          if (newStudyName) {
            // Add the study to the datastructure.
            newStudyWeight = Object.keys(window.fg.mindmap.data.studies).length + 1;
            window.fg.mindmap.sortedStudies.push(newStudyName);
            window.fg.mindmap.data.studies[newStudyName] = {
              data: {
                weight: newStudyWeight,
                welcomeMessage: "Lorem ipsum dolor sit amet, consectetur adipiscing elit.",
                resetMessage: "Lorem ipsum dolor sit amet, consectetur adipiscing elit."
              },
              years: {}
            };
            // Create and add the new study to the interface.
            window.fg.mindmap.studySelect.appendChild(new Option(newStudyName, newStudyWeight - 1));
            item = document.createElement("div");
            item.classList.add("study-row");
            item.setAttribute("data-study", newStudyName);
            name = document.createElement("span");
            name.className = "study-name";
            name.innerHTML = newStudyName;
            item.appendChild(name);
            years = document.createElement("span");
            years.className = "study-year-count";
            years.innerHTML = "0 studiejaren";
            item.appendChild(years);
            item.addEventListener("click", (e) => {
              return openStudyListener(e);
            });
            return studiesColumn.insertBefore(item, addStudyButton);
          }
        });
        studiesColumn.appendChild(addStudyButton);
        // Create the right column containing the study details.
        detailsColumn = document.createElement("div");
        detailsColumn.id = "details-column";
        detailsColumn.innerHTML = "<h3 id='placeholder-text'>Selecteer een studie om deze te bewerken</h3>";
        studiesEditorContainer.appendChild(detailsColumn);
        // The close-handler to close the editor.
        removeEditor = () => {
          document.querySelector("#content").removeChild(studiesEditorContainer);
          return window.fg.mindmap.removeOverlay();
        };
        // The close-button in the top right.
        closeButton = document.createElement("i");
        closeButton.id = "study-editor-close-button";
        closeButton.className = "far fa-times-circle";
        closeButton.addEventListener("click", removeEditor);
        studiesEditorContainer.appendChild(closeButton);
        // Show the popup and overlay.
        document.querySelector("#content").appendChild(studiesEditorContainer);
        window.fg.mindmap.showOverlay(removeEditor);
        studiesEditorOpen = false;
        return this;
      }

      createWYSIWYGEditor(value, center, editorCallback) {
        var editor, options, removeContainer, saveButton, wysiwygContainer;
        if (wysiwygEditorOpen) {
          return;
        }
        wysiwygEditorOpen = true;
        // Create the popup-container to hold everything.
        wysiwygContainer = document.createElement("div");
        wysiwygContainer.id = "wysiwyg-container";
        wysiwygContainer.className = "no-drag";
        document.querySelector("#content").appendChild(wysiwygContainer);
        // Create and initialze the WYSIWYG editor.
        editor = document.createElement("div");
        editor.id = "wysiwyg-editor";
        wysiwygContainer.appendChild(editor);
        options = {
          placeholder: "Lorem ipsum dolor sit amet, consectetur adipiscing elit.",
          theme: "snow"
        };
        editor = new Quill('#wysiwyg-editor', options);
        if (value) {
          editor.root.innerHTML = value;
        }
        if (center) {
          editor.root.style.textAlign = "center";
        }
        // Callback to save the value and
        removeContainer = () => {
          editorCallback(editor.root.innerHTML);
          document.querySelector("#content").removeChild(wysiwygContainer);
          return wysiwygEditorOpen = false;
        };
        // Create the save button.
        saveButton = document.createElement("button");
        saveButton.id = "wysiwyg-save-button";
        saveButton.innerHTML = "Opslaan <i class='fas fa-save'></i>";
        saveButton.addEventListener("click", () => {
          removeContainer();
          return window.fg.mindmap.removeOverlay();
        });
        wysiwygContainer.appendChild(saveButton);
        // Show the overlay.
        window.fg.mindmap.showOverlay(removeContainer);
        // And actually display the WYSIWYG editor.
        wysiwygContainer.style.display = "block";
        return this;
      }

      // Creates a block-item to hold a bunch of related fields.
      createInputBlock(name) {
        var block, title;
        // The container to hold everything.
        block = document.createElement("div");
        block.className = "editor-item";
        // The bold title of the item.
        title = document.createElement("label");
        title.className = "title";
        title.innerHTML = name;
        block.appendChild(title);
        return block;
      }

      // Builds the HTML for an editor-entry.
      createItem(name, value) {
        // The container to hold everything.
        this.block = this.createInputBlock(NORMALIZED_NAMES[name]);
        // Add the appropriate input.
        this.addInputFields(name, value);
        return this;
      }

      // Routes the propertie to the right input-field creating method.
      addInputFields(name, value) {
        if (indexOf.call(Object.keys(PROPERTY_TYPES), name) >= 0) {
          this[`${PROPERTY_TYPES[name]}InputCreate`](name, value);
        }
        return this;
      }

      // Adds the newly built block to the editor.
      addToEditor() {
        this.editorContent.appendChild(this.block);
        return this;
      }

      // Listens for any changes made in the editor to automatically
      // reflect those changes in the view.
      listenForChanges() {
        var field, i, j, len, len1, ref, ref1;
        ref = this.editorContent.querySelectorAll(".property");
        for (i = 0, len = ref.length; i < len; i++) {
          field = ref[i];
          field.addEventListener("change", (event) => {
            var property;
            property = event.target.getAttribute("data-property");
            this.updateProperty(property);
          });
        }
        ref1 = this.editorContent.querySelectorAll(".array-property");
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          field = ref1[j];
          this.makeRichTextInput(field);
          field.addEventListener("change", (event) => {
            var property;
            property = event.target.getAttribute("data-property");
            this.updateArrayProperty(property);
          });
        }
        return this;
      }

      // Updates a single property.
      updateProperty(property) {
        if (property.split("_").length > 1) {
          this.node.nodeData[property.split("_")[0]][property.split("_")[1]] = event.target.value || event.target.innerHTML;
        } else {
          this.node.nodeData[property] = event.target.value || event.target.innerHTML;
        }
        this.node.build().addListeners().rerender();
        return this;
      }

      // Updates a property consisting of an array of values,
      // such as the theorems.
      updateArrayProperty(property) {
        var entry, i, len, new_values, ref;
        new_values = [];
        ref = this.editorContent.querySelectorAll(`[data-property='${property}']`);
        for (i = 0, len = ref.length; i < len; i++) {
          entry = ref[i];
          new_values.push(entry.innerHTML);
        }
        if (property.split("_").length > 1) {
          this.node.nodeData[property.split("_")[0]][property.split("_")[1]] = new_values;
        } else {
          this.node.nodeData[property] = new_values;
        }
        this.node.build().addListeners().rerender();
        return this;
      }

      // Disables default browser behaviour for this input to instead
      // open up the WYSIWYG editor.
      makeRichTextInput(input) {
        input.addEventListener("click", (e) => {
          var centerEditor;
          e.preventDefault();
          centerEditor = false;
          if (input.id === "property-messages_open" || input.id === "property-messages_close" || input.classList.contains("feedbackMessage")) {
            centerEditor = true;
          }
          this.createWYSIWYGEditor(input.innerHTML, centerEditor, (value) => {
            input.innerHTML = value;
            return input.dispatchEvent(new Event("change"));
          });
          document.querySelector(".ql-editor").focus();
          return false;
        });
        return this;
      }

      // Creates a simple text-field input.
      textInputCreate(name, value) {
        var input;
        input = document.createElement("div");
        input.id = `property-${name}`;
        input.className = "input property";
        input.setAttribute("data-property", name);
        input.innerHTML = value;
        this.makeRichTextInput(input);
        this.block.appendChild(input);
        return this;
      }

      // Creates a multiline text-field input.
      multilinetextInputCreate(name, value) {
        var input;
        input = document.createElement("div");
        input.id = `property-${name}`;
        input.className = "textarea property";
        input.setAttribute("data-property", name);
        input.innerHTML = value;
        this.makeRichTextInput(input);
        this.block.appendChild(input);
        return this;
      }

      // Creates a standard number-input.
      numberInputCreate(name, value) {
        var input;
        input = document.createElement("input");
        input.type = "number";
        input.id = `property-${name}`;
        input.className = "property";
        input.setAttribute("data-property", name);
        input.value = value;
        this.block.appendChild(input);
        return this;
      }

      // Creates an HTML5 color-input.
      colorInputCreate(name, value) {
        var colorInput, hexBefore, hexBlock, hexInput;
        hexBlock = document.createElement("div");
        hexBlock.className = "hexblock";
        hexBefore = document.createElement("div");
        hexBefore.className = "hexbefore";
        hexBefore.innerHTML = "#";
        hexBlock.appendChild(hexBefore);
        hexInput = document.createElement("input");
        hexInput.type = "text";
        hexInput.className = "hexinput";
        hexInput.value = value.substr(1);
        hexBlock.appendChild(hexInput);
        colorInput = document.createElement("input");
        colorInput.type = "color";
        colorInput.id = `property-${name}`;
        colorInput.className = "property";
        colorInput.setAttribute("data-property", name);
        colorInput.value = value;
        hexInput.addEventListener("change", function() {
          colorInput.value = `#${hexInput.value}`;
          return colorInput.dispatchEvent(new Event("change"));
        });
        colorInput.addEventListener("change", function() {
          return hexInput.value = colorInput.value.substr(1);
        });
        this.block.appendChild(hexBlock);
        this.block.appendChild(colorInput);
        return this;
      }

      feedbackInputCreate(name, values) {
        var addButton, blockCopy, createFeedbackInput, message, percentage, updateFeedback;
        updateFeedback = () => {
          var feedbackBlock, i, len, message, newFeedback, percentage, ref;
          newFeedback = {};
          ref = document.querySelectorAll(".feedbackBlock");
          for (i = 0, len = ref.length; i < len; i++) {
            feedbackBlock = ref[i];
            percentage = feedbackBlock.querySelector("input[type='number']").value;
            message = feedbackBlock.querySelector(".feedbackMessage").innerHTML;
            newFeedback[percentage] = message;
          }
          return this.node.nodeData.data.feedback = newFeedback;
        };
        createFeedbackInput = (percentage, message) => {
          var feedbackBlock, feedbackMessage, feedbackTriggerBlock, feedbackTriggerInput, feedbackTriggerPercentage, removeButton;
          feedbackBlock = document.createElement("div");
          feedbackBlock.className = "feedbackBlock";
          feedbackTriggerBlock = document.createElement("div");
          feedbackTriggerBlock.className = "feedbackTriggerBlock";
          feedbackTriggerInput = document.createElement("input");
          feedbackTriggerInput.type = "number";
          feedbackTriggerInput.max = 100;
          feedbackTriggerInput.min = 0;
          if (percentage) {
            feedbackTriggerInput.value = percentage;
          }
          feedbackTriggerInput.addEventListener("change", function() {
            return updateFeedback();
          });
          feedbackTriggerBlock.appendChild(feedbackTriggerInput);
          feedbackTriggerPercentage = document.createElement("div");
          feedbackTriggerPercentage.className = "percentage";
          feedbackTriggerPercentage.innerHTML = "%";
          feedbackTriggerBlock.appendChild(feedbackTriggerPercentage);
          feedbackBlock.appendChild(feedbackTriggerBlock);
          feedbackMessage = document.createElement("div");
          feedbackMessage.className = "feedbackMessage input";
          feedbackMessage.innerHTML = message;
          feedbackMessage.addEventListener("change", function() {
            return updateFeedback();
          });
          this.makeRichTextInput(feedbackMessage);
          feedbackBlock.appendChild(feedbackMessage);
          removeButton = document.createElement("i");
          removeButton.className = "removeButton far fa-trash-alt";
          feedbackBlock.appendChild(removeButton);
          removeButton.addEventListener("click", (event) => {
            event.target.parentElement.parentElement.removeChild(event.target.parentElement);
            return updateFeedback();
          });
          return feedbackBlock;
        };
        for (percentage in values) {
          message = values[percentage];
          this.block.appendChild(createFeedbackInput(percentage, message));
        }
        // Add the 'add'-button.
        addButton = document.createElement("button");
        addButton.className = "add-button";
        addButton.innerHTML = "Toevoegen <i class='fas fa-plus-square'></i>";
        blockCopy = this.block;
        addButton.addEventListener("click", () => {
          return blockCopy.insertBefore(createFeedbackInput(false, "Lorem ipsum dolor"), addButton);
        });
        this.block.appendChild(addButton);
        return this;
      }

      // Creates multiple text inputs for properties that
      // consist of multiple values, such as the theorems.
      multitextInputCreate(name, values) {
        var addButton, blockCopy, i, input, inputBlock, len, removeButton, value;
// Add all existing items as input blocks.
        for (i = 0, len = values.length; i < len; i++) {
          value = values[i];
          inputBlock = document.createElement("div");
          inputBlock.className = "inputblock";
          input = document.createElement("div");
          input.className = "input array-property";
          input.setAttribute("data-property", name);
          input.innerHTML = value;
          inputBlock.appendChild(input);
          removeButton = document.createElement("i");
          removeButton.className = "removeButton far fa-trash-alt";
          inputBlock.appendChild(removeButton);
          removeButton.addEventListener("click", (event) => {
            event.target.parentElement.parentElement.removeChild(event.target.parentElement);
            return this.updateArrayProperty(name);
          });
          this.block.appendChild(inputBlock);
        }
        // Add the 'add'-button.
        addButton = document.createElement("button");
        addButton.className = "add-button";
        addButton.innerHTML = "Toevoegen <i class='fas fa-plus-square'></i>";
        blockCopy = this.block;
        addButton.addEventListener("click", () => {
          inputBlock = document.createElement("div");
          inputBlock.className = "inputblock";
          input = document.createElement("div");
          input.className = "input array-property";
          input.setAttribute("data-property", name);
          input.innerHTML = "";
          inputBlock.appendChild(input);
          input.addEventListener("change", (event) => {
            return this.updateArrayProperty(name);
          });
          this.makeRichTextInput(input);
          removeButton = document.createElement("i");
          removeButton.className = "removeButton far fa-trash-alt";
          inputBlock.appendChild(removeButton);
          blockCopy.insertBefore(inputBlock, addButton);
          return input.focus();
        });
        this.block.appendChild(addButton);
        return this;
      }

      // Creates a special input for video-urls that is capable
      // of automatically detecting supported video platforms.
      videourlInputCreate(name, value) {
        var input, openInUrl, platformLogo;
        input = document.createElement("input");
        input.type = "text";
        input.id = `property-${name}`;
        input.className = "property";
        input.setAttribute("data-property", name);
        input.value = value;
        this.block.appendChild(input);
        // The open-in URL.
        openInUrl = document.createElement("a");
        openInUrl.className = "platform-url";
        openInUrl.href = value;
        openInUrl.target = "_blank";
        openInUrl.innerHTML = "Open in ";
        if (value.length === 0) {
          openInUrl.style.display = "none";
        }
        platformLogo = document.createElement("i");
        platformLogo.className = `fab fa-${this.node.nodeData.data.type}`;
        openInUrl.appendChild(platformLogo);
        this.block.appendChild(openInUrl);
        // The URL parsing.
        input.addEventListener("change", (event) => {
          var elements, parser, validURL, videoID;
          parser = document.createElement("a");
          parser.href = input.value;
          validURL = false;
          // Parse Youtube URLs.
          if (parser.hostname === "www.youtube.com" || parser.hostname === "youtube.com") {
            this.node.nodeData.data.type = "youtube";
            if (parser.pathname.startsWith("/watch")) {
              elements = parser.search.split("&")[0].split("=");
              if (elements[0] === "?v") {
                videoID = elements[1];
                input.value = `https://www.youtube.com/embed/${videoID}`;
                openInUrl.href = `https://www.youtube.com/watch?v=${videoID}`;
                platformLogo.className = "fab fa-youtube";
                validURL = true;
              }
            }
          // Parse Google Drive URLs.
          } else if (parser.hostname === "www.drive.google.com" || parser.hostname === "drive.google.com") {
            this.node.nodeData.data.type = "google-drive";
            if (parser.pathname.startsWith("/file/d/")) {
              videoID = parser.pathname.replace("/file/d/", "").split("/")[0];
              input.value = `https://drive.google.com/file/d/${videoID}/preview`;
              openInUrl.href = `https://drive.google.com/file/d/${videoID}/view`;
              platformLogo.className = "fab fa-google-drive";
              validURL = true;
            }
          }
          if (!validURL) {
            window.fg.sidemenu.errorMessage("Ongeldige video link");
            return event.stopPropagation();
          }
        });
        return this;
      }

      // Create an up- and down-buttons to adjust the horizontal position of a node
      // and left- and right-buttons to move rootnodes to a different side.
      positionInputCreate(name, value) {
        var currentIndex, downButton, leftButton, maxWeight, rightButton, siblings, upButton;
        siblings = this.node.targetParent.querySelectorAll("li.child-item");
        currentIndex = 1 + Array.prototype.indexOf.call(siblings, this.node.html);
        maxWeight = siblings.length;
        upButton = document.createElement("button");
        upButton.className = "vertical-position-button";
        upButton.innerHTML = "<span>Omhoog</span> <i class='fas fa-sort-up'></i>";
        if (currentIndex === 1) {
          upButton.disabled = true;
        }
        this.block.appendChild(upButton);
        downButton = document.createElement("button");
        downButton.className = "vertical-position-button";
        downButton.innerHTML = "<span>Omlaag</span> <i class='fas fa-sort-down'></i>";
        if (currentIndex === maxWeight) {
          downButton.disabled = true;
        }
        this.block.appendChild(downButton);
        upButton.addEventListener("click", (event) => {
          currentIndex -= 1;
          this.node.targetParent.insertBefore(this.node.html, this.node.html.previousElementSibling);
          this.node.nodeData.weight = currentIndex;
          if (currentIndex === 1) {
            upButton.disabled = true;
          } else {
            upButton.disabled = false;
          }
          if (currentIndex === maxWeight) {
            return downButton.disabled = true;
          } else {
            return downButton.disabled = false;
          }
        });
        downButton.addEventListener("click", (event) => {
          currentIndex += 1;
          this.node.targetParent.insertBefore(this.node.html.nextElementSibling, this.node.html);
          this.node.nodeData.weight = currentIndex;
          if (currentIndex === 1) {
            upButton.disabled = true;
          } else {
            upButton.disabled = false;
          }
          if (currentIndex === maxWeight) {
            return downButton.disabled = true;
          } else {
            return downButton.disabled = false;
          }
        });
        if (this.node.isRootNode) {
          leftButton = document.createElement("button");
          leftButton.className = "horizontal-position-button";
          leftButton.innerHTML = "<i class='fas fa-caret-left'></i> Links";
          if (this.node.nodeData.side === "left") {
            leftButton.disabled = true;
          }
          this.block.appendChild(leftButton);
          rightButton = document.createElement("button");
          rightButton.className = "horizontal-position-button";
          rightButton.innerHTML = "Rechts <i class='fas fa-caret-right'></i>";
          if (this.node.nodeData.side === "right") {
            rightButton.disabled = true;
          }
          this.block.appendChild(rightButton);
          leftButton.addEventListener("click", (event) => {
            if (this.node.html.querySelector(".chevron")) {
              this.node.html.querySelector(".chevron").classList.replace("right", "left");
            }
            this.node.nodeData.side = "left";
            this.node.nodeData.weight = document.querySelectorAll("#leftbranch .child-item.root-child").length + 1;
            this.node.targetParent = document.querySelector("#leftbranch");
            document.querySelector("#leftbranch").appendChild(this.node.html);
            leftButton.disabled = true;
            rightButton.disabled = false;
            return this.openInEditor();
          });
          rightButton.addEventListener("click", (event) => {
            if (this.node.html.querySelector(".chevron")) {
              this.node.html.querySelector(".chevron").classList.replace("left", "right");
            }
            this.node.nodeData.side = "right";
            this.node.nodeData.weight = document.querySelectorAll("#rightbranch .child-item.root-child").length + 1;
            this.node.targetParent = document.querySelector("#rightbranch");
            document.querySelector("#rightbranch").appendChild(this.node.html);
            leftButton.disabled = false;
            rightButton.disabled = true;
            return this.openInEditor();
          });
        }
        return this;
      }

      // Creates the drop-down that can be used to switch the type of the node
      // to a different type. On switching, it clears the node data.
      nodetypeInputCreate() {
        var dropdown, dropdownContainer, i, len, option, type, types;
        // The currently supported node-types.
        types = [["text", "Tekst"], ["video", "Video"], ["checklist", "Checklist"]];
        dropdownContainer = document.createElement("span");
        dropdownContainer.className = "dropdown editor-dropdown";
        dropdown = document.createElement("select");
        dropdownContainer.appendChild(dropdown);
        for (i = 0, len = types.length; i < len; i++) {
          type = types[i];
          option = document.createElement("option");
          option.value = type[0];
          option.innerHTML = type[1];
          dropdown.appendChild(option);
        }
        dropdown.value = this.node.nodeData.type;
        this.block.appendChild(dropdownContainer);
        // Bind the eventlistener to the dropdown to change the
        // node type when a different option is selected.
        dropdown.addEventListener("change", (event) => {
          var id, isRootNode, newType, nodeData, targetParent;
          // Get the relevant properties from the old node.
          targetParent = this.node.targetParent;
          id = this.node.html.id;
          nodeData = this.node.nodeData;
          isRootNode = this.node.isRootNode;
          // Set the data-property based on the new node type.
          newType = event.target.value;
          if (newType === "text") {
            nodeData.data = {
              text: "Lorem ipsum dolor sit amet, consectetur adipisicing elit"
            };
          } else if (newType === "video") {
            nodeData.data = {
              type: "youtube",
              url: "https://www.youtube.com/embed/NpEaa2P7qZI",
              text: "Lorem ipsum dolor sit amet, consectetur adipisicing elit"
            };
          } else if (newType === "checklist") {
            nodeData.data = {
              theorems: ["Lorem ipsum dolor sit amet, consectetur adipisicing elit"],
              feedback: {
                "50": "Lorem ipsum dolor sit amet, consectetur adipisicing elit"
              }
            };
          }
          nodeData.type = newType;
          // Delete the relation with the parent.
          if (isRootNode) {
            window.fg.mindmap.mindmapData.nodes = window.fg.mindmap.mindmapData.nodes.filter((rootnode) => {
              return rootnode !== this.node.nodeData;
            });
          } else {
            this.node.nodeData.parentObject.nodeData.children = this.node.nodeData.parentObject.nodeData.children.filter((child) => {
              return child !== this.node.nodeData;
            });
          }
          // Delete the existing node.
          this.node = null;
          // Create the new node, set some properties back and render it.
          this.node = new supportedNodeTypes[newType](nodeData, isRootNode);
          this.node.targetParent = targetParent;
          this.node.build();
          this.node.html.id = id;
          this.node.addListeners().rerender();
          this.openInEditor();
          // Add the node back to the parent.
          if (isRootNode) {
            return window.fg.mindmap.mindmapData.nodes.push(this.node.nodeData);
          } else {
            return this.node.nodeData.parentObject.nodeData.children.push(this.node.nodeData);
          }
        });
        return this;
      }

      // Creates two buttons to add and remove nodes.
      // Prevents the user from removing all nodes.
      addRemoveButtonCreate() {
        var addButton, addRootButton, removeButton;
        // The container to hold the buttons.
        this.block = this.createInputBlock("Node");
        addButton = document.createElement("button");
        addButton.className = "node-add-button";
        addButton.innerHTML = "Extra node toevoegen <i class='fas fa-plus-square'></i>";
        this.block.appendChild(addButton);
        if (this.node.isRootNode) {
          addRootButton = document.createElement("button");
          addRootButton.className = "node-add-root-button";
          addRootButton.innerHTML = "Extra root node toevoegen <i class='fas fa-plus-square'></i>";
          this.block.appendChild(addRootButton);
        }
        removeButton = document.createElement("button");
        removeButton.className = "node-remove-button";
        removeButton.innerHTML = "Node verwijderen <i class='far fa-trash-alt'></i>";
        removeButton.disabled = document.querySelectorAll(".node").length <= 1;
        this.block.appendChild(removeButton);
        // Adding a new child-node.
        addButton.addEventListener("click", (event) => {
          var newNode, newRenderedNode;
          newNode = {
            children: [],
            color: "#6b2565",
            data: {
              text: "Lorem ipsum dolor"
            },
            messages: {
              open: "",
              close: ""
            },
            name: "Nieuwe node...",
            type: "text",
            weight: this.node.nodeData.children.length
          };
          this.node.nodeData.children.push(newNode);
          if (!this.node.expanded) {
            if (this.node.nodeData.children.length === 1) {
              this.node.addExpandButton();
            }
            this.node.html.querySelector(".node-expand").classList.toggle("active");
            this.node.expanded = true;
            return this.node.expandChildren();
          } else {
            newRenderedNode = new TextNode(newNode);
            newRenderedNode.nodeData.parent = this.node.html;
            return newRenderedNode.build().addListeners().render();
          }
        });
        // Adding another root-node.
        if (this.node.isRootNode) {
          addRootButton.addEventListener("click", (event) => {
            var newNode, newRenderedNode;
            newNode = {
              children: [],
              color: "#6b2565",
              data: {
                text: "Lorem ipsum dolor"
              },
              messages: {
                open: "",
                close: ""
              },
              name: "Nieuwe node...",
              side: this.node.nodeData.side,
              type: "text",
              weight: this.node.nodeData.children.length
            };
            window.fg.mindmap.mindmapData.nodes.push(newNode);
            newRenderedNode = new TextNode(newNode, true);
            return newRenderedNode.build().addListeners().render();
          });
        }
        // Removing the current node.
        removeButton.addEventListener("click", (event) => {
          if (!this.node.isRootNode) {
            // Remove the parents link to this node.
            this.node.nodeData.parentObject.nodeData.children = this.node.nodeData.parentObject.nodeData.children.filter((child) => {
              return child !== this.node.nodeData;
            });
            this.node.html.parentNode.removeChild(this.node.html);
            // Explicitly signal the garbage collector to clean this node and its nested children.
            this.node = null;
            // Reset the sidemenu content.
            return window.fg.sidemenu.reset();
          } else {
            // Prevent deletion of the last rootnode.
            if (document.querySelectorAll(".root-child").length === 1) {
              return window.fg.sidemenu.errorMessage("De laatste root-node kan niet verwijderd worden");
            } else {
              window.fg.mindmap.mindmapData.nodes = window.fg.mindmap.mindmapData.nodes.filter((rootnode) => {
                return rootnode !== this.node.nodeData;
              });
              this.node.html.parentNode.removeChild(this.node.html);
              // Reset the sidemenu content.
              return window.fg.sidemenu.reset();
            }
          }
        });
        return this;
      }

    };

    // Creates a popup that enables the user to edit
    // studies, years and their order.
    studiesEditorOpen = false;

    // Creates a popup with an HTML WYSIWYG editor
    // to allow for rich text input.
    wysiwygEditorOpen = false;

    return Editor;

  }).call(this);

  // Represents the editor sidemenu used to edit and
  // manage the contents of the map.
  SideMenu = class SideMenu {
    // Creates the DOM-object for the editor-sidemenu and inserts
    // it into the page.
    constructor() {
      this.content = document.getElementById("content");
      this.closed = true;
      // Build the sidemenu basics.
      this.buildSideMenu();
      this.sliding = false;
      this.previousMouseX = 0;
    }

    // Binds all eventlisteners.
    startListening() {
      this.bindSlideButton();
      this.bindSliderMouseDown();
      this.bindSliderMouseUp();
      this.bindSliderMouseMove();
      return this.bindSaveButton();
    }

    // Binds the eventlisteners to the slide in/out button.
    bindSlideButton() {
      return this.slideButton.addEventListener("click", () => {
        if (this.sidemenu.classList.contains("sidemenu-open")) {
          this.slideButton.classList.add("closed");
          return this.slideOut();
        } else {
          this.slideButton.classList.remove("closed");
          return this.slideIn();
        }
      });
    }

    // Binds the mousedown handler so we know when the users starts
    // expanding or shrinking the sidemenu.
    bindSliderMouseDown() {
      return this.sidemenuSlider.addEventListener("mousedown", (event) => {
        event.preventDefault();
        this.sliding = true;
        return this.previousMouseX = event.clientX;
      });
    }

    // Binds the mouseup handler so we know when the users stops
    // expanding or shrinking the sidemenu.
    bindSliderMouseUp() {
      return document.addEventListener("mouseup", (event) => {
        event.preventDefault();
        return this.sliding = false;
      });
    }

    // Binds the mousemove handler so we know how to expand
    // or shrink the sidemenu based on the user's mouse movements.
    bindSliderMouseMove() {
      return document.addEventListener("mousemove", (event) => {
        var movement, newWidth;
        if (this.sliding) {
          event.preventDefault();
          movement = event.clientX - this.previousMouseX;
          newWidth = Math.min(Math.max(this.sidemenu.clientWidth - movement, window.screen.width * 0.15), window.screen.width * 0.6);
          this.sidemenu.style.width = newWidth + "px";
          this.sidemenu.style.left = "calc(100% - " + newWidth + "px)";
          this.content.style.width = "calc(100% - " + newWidth + "px)";
          return this.previousMouseX = event.clientX;
        }
      });
    }

    // Starts an animation to shrink the main content view
    // while sliding in the sidemenu.
    slideIn() {
      this.closed = false;
      this.content.removeAttribute("style");
      this.sidemenu.removeAttribute("style");
      this.content.classList.remove("sidemenu-closed");
      this.content.classList.add("sidemenu-open");
      this.sidemenu.classList.add("sidemenu-open");
      return this.sidemenu.classList.remove("sidemenu-closed");
    }

    // Starts an animation to expand the main content view
    // while sliding out the sidemenu.
    slideOut() {
      this.closed = true;
      this.content.removeAttribute("style");
      this.sidemenu.removeAttribute("style");
      this.content.classList.remove("sidemenu-open");
      this.content.classList.add("sidemenu-closed");
      this.sidemenu.classList.remove("sidemenu-open");
      return this.sidemenu.classList.add("sidemenu-closed");
    }

    // Builds and inserts the HTML for the editor sidemenu.
    buildSideMenu() {
      var footer, header, placeholder, title;
      // The sidemenu div itself.
      this.sidemenu = document.createElement("div");
      this.sidemenu.id = "editor-sidemenu";
      // The header.
      header = document.createElement("div");
      header.id = "editor-sidemenu-header";
      this.sidemenu.appendChild(header);
      title = document.createElement("h2");
      title.innerHTML = "Flow & Grow Editor";
      header.appendChild(title);
      this.lastSaved = document.createElement("h4");
      this.lastSaved.id = "editor-sidemenu-last-saved";
      this.lastSaved.innerHTML = "Laatst opgeslagen: nooit";
      header.appendChild(this.lastSaved);
      // Open/close button
      this.slideButton = document.createElement("button");
      this.slideButton.id = "editor-sidemenu-slidebutton";
      this.slideButton.innerHTML = "<i class='fas fa-angle-double-right'></i>";
      this.sidemenu.appendChild(this.slideButton);
      // The slider to make the sidemenu smaller or bigger.
      this.sidemenuSlider = document.createElement("div");
      this.sidemenuSlider.id = "editor-sidemenu-slider";
      this.sidemenu.appendChild(this.sidemenuSlider);
      // The content of the sidemenu.
      this.sidemenuContent = document.createElement("div");
      this.sidemenuContent.id = "editor-sidemenu-content";
      this.sidemenu.appendChild(this.sidemenuContent);
      // Placeholder text.
      placeholder = document.createElement("div");
      placeholder.id = "editor-sidemenu-placeholder";
      placeholder.innerHTML = "Gebruik <b>alt + muisklik</b> om een element te bewerken.";
      this.sidemenuContent.appendChild(placeholder);
      // The footer.
      footer = document.createElement("div");
      footer.id = "editor-sidemenu-footer";
      this.sidemenu.appendChild(footer);
      // Save button.
      this.saveButton = document.createElement("button");
      this.saveButton.id = "editor-sidemenu-savebutton";
      this.saveButton.innerHTML = "Opslaan&nbsp;&nbsp;<i class='fas fa-save'></i>";
      footer.appendChild(this.saveButton);
      // 'Notificaton' banner.
      this.banner = document.createElement("div");
      this.banner.id = "editor-sidemenu-banner";
      footer.appendChild(this.banner);
      return document.getElementById("container").appendChild(this.sidemenu);
    }

    // Resets the state of the sidemenu to the placeholder text.
    reset() {
      var placeholder;
      placeholder = document.createElement("div");
      placeholder.id = "editor-sidemenu-placeholder";
      placeholder.innerHTML = "Gebruik <b>alt + muisklik</b> om een element te bewerken.";
      this.sidemenuContent.innerHTML = "";
      return this.sidemenuContent.appendChild(placeholder);
    }

    // Displays a success-message in the footer banner.
    successMessage(message) {
      this.banner.innerHTML = message;
      this.banner.className = "success";
      return setTimeout((() => {
        this.banner.className = "";
        return this.banner.innerHTML = "";
      }), 5000);
    }

    // Displays an error-message in the footer banner.
    errorMessage(message) {
      this.banner.innerHTML = message;
      this.banner.className = "error";
      return setTimeout((() => {
        this.banner.className = "";
        return this.banner.innerHTML = "";
      }), 5000);
    }

    // Binds the click-listener to the save-button.
    bindSaveButton() {
      return this.saveButton.addEventListener("click", () => {
        var cleanData, httpRequest;
        this.saveButton.disabled = true;
        this.saveButton.innerHTML = "Aan het opslaan...&nbsp;&nbsp;<i class='fas fa-pause-circle'></i>";
        httpRequest = new XMLHttpRequest();
        httpRequest.onreadystatechange = () => {
          if (httpRequest.readyState === XMLHttpRequest.DONE) {
            if (httpRequest.status === 200) {
              this.lastSaved.innerHTML = `Laatst opgeslagen: ${("0" + new Date().getHours()).slice(-2)}:${("0" + new Date().getMinutes()).slice(-2)}`;
              this.successMessage("Mindmap opgeslagen!");
              this.saveButton.innerHTML = "Opslaan&nbsp;&nbsp;<i class='fas fa-save'></i>";
              return this.saveButton.disabled = false;
            } else {
              this.errorMessage("Kon de mindmap niet opslaan!");
              console.error("Couldn't save!", httpRequest);
              this.saveButton.innerHTML = "Opslaan&nbsp;&nbsp;<i class='fas fa-save'></i>";
              return this.saveButton.disabled = false;
            }
          }
        };
        httpRequest.open("post", "save.php");
        httpRequest.setRequestHeader("Content-Type", "application/json", true);
        cleanData = (json) => {
          var child, cleanChildren, i, j, k, l, len, len1, len2, len3, node, ref, ref1, ref2, ref3, study, updateWeight, year;
          updateWeight = (node) => {
            node.weight = Array.from(node.element.parentNode.childNodes).indexOf(node.element);
            return delete node["element"];
          };
          cleanChildren = (node) => {
            var child, i, len, ref, results;
            if (node["parentObject"]) {
              delete node["parentObject"];
            }
            if (node.element) {
              updateWeight(node);
            }
            if (node.children) {
              ref = node.children;
              results = [];
              for (i = 0, len = ref.length; i < len; i++) {
                child = ref[i];
                results.push(cleanChildren(child));
              }
              return results;
            }
          };
          ref = Object.keys(json.studies);
          for (i = 0, len = ref.length; i < len; i++) {
            study = ref[i];
            ref1 = Object.keys(json.studies[study].years);
            for (j = 0, len1 = ref1.length; j < len1; j++) {
              year = ref1[j];
              ref2 = json.studies[study].years[year].nodes;
              for (k = 0, len2 = ref2.length; k < len2; k++) {
                node = ref2[k];
                if (node.element) {
                  updateWeight(node);
                }
                ref3 = node.children;
                for (l = 0, len3 = ref3.length; l < len3; l++) {
                  child = ref3[l];
                  cleanChildren(child);
                }
              }
            }
          }
          return json;
        };
        return httpRequest.send(JSON.stringify(cleanData(window.fg.mindmap.data)));
      });
    }

  };

  window.fg = {};

  document.addEventListener("DOMContentLoaded", function(event) {
    fg.editor = new Editor;
    BaseNode.prototype.externalClickListeners = [fg.editor.editorLink];
    fg.sidemenu = new SideMenu;
    fg.mindmap = new Mindmap(function() {
      return fg.editor.addEditStudiesButton();
    });
    fg.panHandler = new PanHandler;
    fg.clickHandler = new ClickHandler;
    fg.sidemenu.startListening();
    fg.sidemenu.slideIn();
    fg.panHandler.startListening();
    return fg.clickHandler.startListening();
  });

}).call(this);
